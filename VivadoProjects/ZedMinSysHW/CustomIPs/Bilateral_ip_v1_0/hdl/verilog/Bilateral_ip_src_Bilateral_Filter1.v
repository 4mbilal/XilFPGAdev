// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\BilateralFilterIP\Bilateral_ip_src_Bilateral_Filter1.v
// Created: 2021-04-16 01:15:53
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Bilateral_ip_src_Bilateral_Filter1
// Source Path: BilateralFilterIP/BilateralFilter_HW/Bilateral Filter1
// Hierarchy Level: 1
// 
// Bilateral Filter
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Bilateral_ip_src_Bilateral_Filter1
          (clk,
           reset,
           enb,
           in0,
           in1_hStart,
           in1_hEnd,
           in1_vStart,
           in1_vEnd,
           in1_valid,
           out0,
           out1_hStart,
           out1_hEnd,
           out1_vStart,
           out1_vEnd,
           out1_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] in0;  // uint8
  input   in1_hStart;
  input   in1_hEnd;
  input   in1_vStart;
  input   in1_vEnd;
  input   in1_valid;
  output  [7:0] out0;  // uint8
  output  out1_hStart;
  output  out1_hEnd;
  output  out1_vStart;
  output  out1_vEnd;
  output  out1_valid;


  reg [7:0] dataInReg;  // uint8
  reg  hStartInReg;
  reg  hendInReg;
  reg  vStartInReg;
  reg  vendInReg;
  reg  validInReg;
  wire [7:0] LMKDataOut_0;  // uint8
  wire [7:0] LMKDataOut_1;  // uint8
  wire [7:0] LMKDataOut_2;  // uint8
  wire [7:0] LMKDataOut_3;  // uint8
  wire [7:0] LMKDataOut_4;  // uint8
  wire [7:0] LMKDataOut_5;  // uint8
  wire [7:0] LMKDataOut_6;  // uint8
  wire [7:0] LMKDataOut_7;  // uint8
  wire [7:0] LMKDataOut_8;  // uint8
  wire LMKhStartOut;
  wire LMKhEndOut;
  wire LMKvStartOut;
  wire LMKvEndOut;
  wire LMKvalidOut;
  wire LMKprocessOut;
  wire [7:0] preFilterDataOut;  // uint8
  wire prehStartOut;
  wire prehEndOut;
  wire prevStartOut;
  wire prevEndOut;
  wire preValdiOut;
  wire [7:0] zeroOut_1;  // uint8
  wire [7:0] preDataOut;  // uint8
  reg [7:0] intdelay_reg [0:3];  // ufix8 [4]
  wire [7:0] intdelay_reg_next [0:3];  // ufix8 [4]
  wire [7:0] dataOut;  // uint8
  reg  [0:3] intdelay_reg_1;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_1;  // ufix1 [4]
  wire hStartOut;
  reg  [0:3] intdelay_reg_2;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_2;  // ufix1 [4]
  wire hEndOut;
  reg  [0:3] intdelay_reg_3;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_3;  // ufix1 [4]
  wire vStartOut;
  reg  [0:3] intdelay_reg_4;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_4;  // ufix1 [4]
  wire vEndOut;
  reg  [0:3] intdelay_reg_5;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_5;  // ufix1 [4]
  wire validOut;


  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        dataInReg <= 8'b00000000;
      end
      else begin
        if (enb) begin
          dataInReg <= in0;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        hStartInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartInReg <= in1_hStart;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        hendInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          hendInReg <= in1_hEnd;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        vStartInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          vStartInReg <= in1_vStart;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        vendInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          vendInReg <= in1_vEnd;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        validInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          validInReg <= in1_valid;
        end
      end
    end



  Bilateral_ip_src_LineBuffer u_LineBuffer (.clk(clk),
                                            .reset(reset),
                                            .enb(enb),
                                            .dataIn(dataInReg),  // uint8
                                            .hStartIn(hStartInReg),
                                            .hEndIn(hendInReg),
                                            .vStartIn(vStartInReg),
                                            .vEndIn(vendInReg),
                                            .validIn(validInReg),
                                            .dataOut_0(LMKDataOut_0),  // uint8
                                            .dataOut_1(LMKDataOut_1),  // uint8
                                            .dataOut_2(LMKDataOut_2),  // uint8
                                            .dataOut_3(LMKDataOut_3),  // uint8
                                            .dataOut_4(LMKDataOut_4),  // uint8
                                            .dataOut_5(LMKDataOut_5),  // uint8
                                            .dataOut_6(LMKDataOut_6),  // uint8
                                            .dataOut_7(LMKDataOut_7),  // uint8
                                            .dataOut_8(LMKDataOut_8),  // uint8
                                            .hStartOut(LMKhStartOut),
                                            .hEndOut(LMKhEndOut),
                                            .vStartOut(LMKvStartOut),
                                            .vEndOut(LMKvEndOut),
                                            .validOut(LMKvalidOut),
                                            .processDataOut(LMKprocessOut)
                                            );

  Bilateral_ip_src_BilatKernel u_imagekernel_inst (.clk(clk),
                                                   .reset(reset),
                                                   .enb(enb),
                                                   .dataIn_0(LMKDataOut_0),  // uint8
                                                   .dataIn_1(LMKDataOut_1),  // uint8
                                                   .dataIn_2(LMKDataOut_2),  // uint8
                                                   .dataIn_3(LMKDataOut_3),  // uint8
                                                   .dataIn_4(LMKDataOut_4),  // uint8
                                                   .dataIn_5(LMKDataOut_5),  // uint8
                                                   .dataIn_6(LMKDataOut_6),  // uint8
                                                   .dataIn_7(LMKDataOut_7),  // uint8
                                                   .dataIn_8(LMKDataOut_8),  // uint8
                                                   .vStartIn(LMKhStartOut),
                                                   .vEndIn(LMKhEndOut),
                                                   .hStartIn(LMKvStartOut),
                                                   .hEndIn(LMKvEndOut),
                                                   .validIn(LMKvalidOut),
                                                   .processData(LMKprocessOut),
                                                   .dataOut(preFilterDataOut),  // uint8
                                                   .hStartOut(prehStartOut),
                                                   .hEndOut(prehEndOut),
                                                   .vStartout(prevStartOut),
                                                   .vEndOut(prevEndOut),
                                                   .validOut(preValdiOut)
                                                   );

  assign zeroOut_1 = 8'b00000000;



  assign preDataOut = (preValdiOut == 1'b0 ? zeroOut_1 :
              preFilterDataOut);



  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 8'b00000000;
        intdelay_reg[1] <= 8'b00000000;
        intdelay_reg[2] <= 8'b00000000;
        intdelay_reg[3] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
        end
      end
    end

  assign dataOut = intdelay_reg[3];
  assign intdelay_reg_next[0] = preDataOut;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];



  assign out0 = dataOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
        intdelay_reg_1[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
          intdelay_reg_1[3] <= intdelay_reg_next_1[3];
        end
      end
    end

  assign hStartOut = intdelay_reg_1[3];
  assign intdelay_reg_next_1[0] = prehStartOut;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];
  assign intdelay_reg_next_1[3] = intdelay_reg_1[2];



  assign out1_hStart = hStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
        end
      end
    end

  assign hEndOut = intdelay_reg_2[3];
  assign intdelay_reg_next_2[0] = prehEndOut;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];



  assign out1_hEnd = hEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
        intdelay_reg_3[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
          intdelay_reg_3[3] <= intdelay_reg_next_3[3];
        end
      end
    end

  assign vStartOut = intdelay_reg_3[3];
  assign intdelay_reg_next_3[0] = prevStartOut;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];
  assign intdelay_reg_next_3[3] = intdelay_reg_3[2];



  assign out1_vStart = vStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
        intdelay_reg_4[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
          intdelay_reg_4[3] <= intdelay_reg_next_4[3];
        end
      end
    end

  assign vEndOut = intdelay_reg_4[3];
  assign intdelay_reg_next_4[0] = prevEndOut;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];
  assign intdelay_reg_next_4[3] = intdelay_reg_4[2];



  assign out1_vEnd = vEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        intdelay_reg_5[0] <= 1'b0;
        intdelay_reg_5[1] <= 1'b0;
        intdelay_reg_5[2] <= 1'b0;
        intdelay_reg_5[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_5[0] <= intdelay_reg_next_5[0];
          intdelay_reg_5[1] <= intdelay_reg_next_5[1];
          intdelay_reg_5[2] <= intdelay_reg_next_5[2];
          intdelay_reg_5[3] <= intdelay_reg_next_5[3];
        end
      end
    end

  assign validOut = intdelay_reg_5[3];
  assign intdelay_reg_next_5[0] = preValdiOut;
  assign intdelay_reg_next_5[1] = intdelay_reg_5[0];
  assign intdelay_reg_next_5[2] = intdelay_reg_5[1];
  assign intdelay_reg_next_5[3] = intdelay_reg_5[2];



  assign out1_valid = validOut;

endmodule  // Bilateral_ip_src_Bilateral_Filter1

