-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Gaussian\DIPfilte_ip_src_RGB2INTENSITY.vhd
-- Created: 2021-04-25 06:11:50
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DIPfilte_ip_src_RGB2INTENSITY
-- Source Path: Gaussian/DIPGauss/Color Space Converter/RGB2INTENSITY
-- Hierarchy Level: 2
-- 
-- RGB to Intensity Converter
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DIPfilte_ip_src_DIPGauss_pkg.ALL;

ENTITY DIPfilte_ip_src_RGB2INTENSITY IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        R                                 :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        G                                 :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        B                                 :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        hStartIn                          :   IN    std_logic;
        hEndIn                            :   IN    std_logic;
        vStartIn                          :   IN    std_logic;
        vEndIn                            :   IN    std_logic;
        validIn                           :   IN    std_logic;
        Intensity                         :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        hStartOut                         :   OUT   std_logic;
        hEndOut                           :   OUT   std_logic;
        vStartOut                         :   OUT   std_logic;
        vEndOut                           :   OUT   std_logic;
        validOut                          :   OUT   std_logic
        );
END DIPfilte_ip_src_RGB2INTENSITY;


ARCHITECTURE rtl OF DIPfilte_ip_src_RGB2INTENSITY IS

  -- Signals
  SIGNAL intdelay_reg                     : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL Mux_Sel                          : std_logic;
  SIGNAL const_zero                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL R_unsigned                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiInDelay1_reg                : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL multiInReg1                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiOut1                        : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL multiOutDelay1_reg               : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL multiOutReg1                     : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL G_unsigned                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiInDelay2_reg                : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL multiInReg2                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiOut2                        : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL multiOutDelay2_reg               : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL multiOutReg2                     : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL adder_add_cast                   : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL adder_add_cast_1                 : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL S1_up                            : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL S1_up_delay                      : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL B_unsigned                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiInDelay3_reg                : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL multiInReg3                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL multiOut3                        : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL multiOutDelay3_reg               : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL multiOutReg3                     : unsigned(23 DOWNTO 0);  -- ufix24_En16
  SIGNAL S1_down_delay                    : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL S1_down_delay_1                  : unsigned(24 DOWNTO 0);  -- ufix25_En16
  SIGNAL adder_add_cast_2                 : unsigned(25 DOWNTO 0);  -- ufix26_En16
  SIGNAL adder_add_cast_3                 : unsigned(25 DOWNTO 0);  -- ufix26_En16
  SIGNAL S2                               : unsigned(25 DOWNTO 0);  -- ufix26_En16
  SIGNAL S2_delay                         : unsigned(25 DOWNTO 0);  -- ufix26_En16
  SIGNAL castout                          : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL cast_delay                       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL SwitchOut                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Intensity_tmp                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL hStart_reg                       : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL hEnd_reg                         : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL vStart_reg                       : std_logic_vector(0 TO 7);  -- ufix1 [8]
  SIGNAL vEnd_reg                         : std_logic_vector(0 TO 7);  -- ufix1 [8]

BEGIN
  intdelay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      intdelay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        intdelay_reg(0) <= validIn;
        intdelay_reg(1 TO 6) <= intdelay_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS intdelay_process;

  Mux_Sel <= intdelay_reg(6);

  const_zero <= to_unsigned(16#00#, 8);

  R_unsigned <= unsigned(R);

  multiInDelay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiInDelay1_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiInDelay1_reg(0) <= R_unsigned;
        multiInDelay1_reg(1) <= multiInDelay1_reg(0);
      END IF;
    END IF;
  END PROCESS multiInDelay1_process;

  multiInReg1 <= multiInDelay1_reg(1);

  multiOut1 <= to_unsigned(16#4C8B#, 16) * multiInReg1;

  multiOutDelay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiOutDelay1_reg <= (OTHERS => to_unsigned(16#000000#, 24));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiOutDelay1_reg(0) <= multiOut1;
        multiOutDelay1_reg(1) <= multiOutDelay1_reg(0);
      END IF;
    END IF;
  END PROCESS multiOutDelay1_process;

  multiOutReg1 <= multiOutDelay1_reg(1);

  G_unsigned <= unsigned(G);

  multiInDelay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiInDelay2_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiInDelay2_reg(0) <= G_unsigned;
        multiInDelay2_reg(1) <= multiInDelay2_reg(0);
      END IF;
    END IF;
  END PROCESS multiInDelay2_process;

  multiInReg2 <= multiInDelay2_reg(1);

  multiOut2 <= to_unsigned(16#9646#, 16) * multiInReg2;

  multiOutDelay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiOutDelay2_reg <= (OTHERS => to_unsigned(16#000000#, 24));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiOutDelay2_reg(0) <= multiOut2;
        multiOutDelay2_reg(1) <= multiOutDelay2_reg(0);
      END IF;
    END IF;
  END PROCESS multiOutDelay2_process;

  multiOutReg2 <= multiOutDelay2_reg(1);

  adder_add_cast <= resize(multiOutReg1, 25);
  adder_add_cast_1 <= resize(multiOutReg2, 25);
  S1_up <= adder_add_cast + adder_add_cast_1;

  intdelay_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      S1_up_delay <= to_unsigned(16#0000000#, 25);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        S1_up_delay <= S1_up;
      END IF;
    END IF;
  END PROCESS intdelay_1_process;


  B_unsigned <= unsigned(B);

  multiInDelay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiInDelay3_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiInDelay3_reg(0) <= B_unsigned;
        multiInDelay3_reg(1) <= multiInDelay3_reg(0);
      END IF;
    END IF;
  END PROCESS multiInDelay3_process;

  multiInReg3 <= multiInDelay3_reg(1);

  multiOut3 <= to_unsigned(16#1D2F#, 16) * multiInReg3;

  multiOutDelay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      multiOutDelay3_reg <= (OTHERS => to_unsigned(16#000000#, 24));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        multiOutDelay3_reg(0) <= multiOut3;
        multiOutDelay3_reg(1) <= multiOutDelay3_reg(0);
      END IF;
    END IF;
  END PROCESS multiOutDelay3_process;

  multiOutReg3 <= multiOutDelay3_reg(1);

  S1_down_delay <= resize(multiOutReg3, 25);

  intdelay_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      S1_down_delay_1 <= to_unsigned(16#0000000#, 25);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        S1_down_delay_1 <= S1_down_delay;
      END IF;
    END IF;
  END PROCESS intdelay_2_process;


  adder_add_cast_2 <= resize(S1_up_delay, 26);
  adder_add_cast_3 <= resize(S1_down_delay_1, 26);
  S2 <= adder_add_cast_2 + adder_add_cast_3;

  intdelay_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      S2_delay <= to_unsigned(16#0000000#, 26);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        S2_delay <= S2;
      END IF;
    END IF;
  END PROCESS intdelay_3_process;


  -- convert dataOut to the data type of R, G, and B
  
  castout <= "11111111" WHEN (S2_delay(25 DOWNTO 24) /= "00") OR (S2_delay(23 DOWNTO 16) = "11111111") ELSE
      S2_delay(23 DOWNTO 16) + ('0' & S2_delay(15));

  intdelay_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      cast_delay <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        cast_delay <= castout;
      END IF;
    END IF;
  END PROCESS intdelay_4_process;


  
  SwitchOut <= const_zero WHEN Mux_Sel = '0' ELSE
      cast_delay;

  intdelay_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Intensity_tmp <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Intensity_tmp <= SwitchOut;
      END IF;
    END IF;
  END PROCESS intdelay_5_process;


  Intensity <= std_logic_vector(Intensity_tmp);

  -- delay hStart
  hStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hStart_reg(0) <= hStartIn;
        hStart_reg(1 TO 7) <= hStart_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS hStart_process;

  hStartOut <= hStart_reg(7);

  -- delay hEnd
  hEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      hEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        hEnd_reg(0) <= hEndIn;
        hEnd_reg(1 TO 7) <= hEnd_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS hEnd_process;

  hEndOut <= hEnd_reg(7);

  -- delay vStart
  vStart_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vStart_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vStart_reg(0) <= vStartIn;
        vStart_reg(1 TO 7) <= vStart_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS vStart_process;

  vStartOut <= vStart_reg(7);

  -- delay vEnd
  vEnd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      vEnd_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        vEnd_reg(0) <= vEndIn;
        vEnd_reg(1 TO 7) <= vEnd_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS vEnd_process;

  vEndOut <= vEnd_reg(7);

  intdelay_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      validOut <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        validOut <= Mux_Sel;
      END IF;
    END IF;
  END PROCESS intdelay_6_process;


END rtl;

