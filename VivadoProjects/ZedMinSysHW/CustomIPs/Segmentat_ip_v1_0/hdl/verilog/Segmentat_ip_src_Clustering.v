// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\Sementation_4K_480p\Segmentat_ip_src_Clustering.v
// Created: 2021-04-17 16:46:28
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Segmentat_ip_src_Clustering
// Source Path: Sementation_4K_480p/Segmentation_HW/K-Means/Clustering
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Segmentat_ip_src_Clustering
          (clk,
           reset,
           enb,
           K_addr,
           RGB_pixel_0,
           RGB_pixel_1,
           RGB_pixel_2,
           Ctrl_vStart,
           Ctrl_valid,
           K_out_0,
           K_out_1,
           K_out_2,
           K_out_3,
           K_out_4,
           K_out_5,
           K_out_6,
           K_out_7,
           K_out_8,
           K_out_9,
           K_out_10,
           K_out_11);


  input   clk;
  input   reset;
  input   enb;
  input   [1:0] K_addr;  // ufix2
  input   signed [17:0] RGB_pixel_0;  // sfix18_En8
  input   signed [17:0] RGB_pixel_1;  // sfix18_En8
  input   signed [17:0] RGB_pixel_2;  // sfix18_En8
  input   Ctrl_vStart;
  input   Ctrl_valid;
  output  signed [17:0] K_out_0;  // sfix18_En8
  output  signed [17:0] K_out_1;  // sfix18_En8
  output  signed [17:0] K_out_2;  // sfix18_En8
  output  signed [17:0] K_out_3;  // sfix18_En8
  output  signed [17:0] K_out_4;  // sfix18_En8
  output  signed [17:0] K_out_5;  // sfix18_En8
  output  signed [17:0] K_out_6;  // sfix18_En8
  output  signed [17:0] K_out_7;  // sfix18_En8
  output  signed [17:0] K_out_8;  // sfix18_En8
  output  signed [17:0] K_out_9;  // sfix18_En8
  output  signed [17:0] K_out_10;  // sfix18_En8
  output  signed [17:0] K_out_11;  // sfix18_En8


  wire valid;
  wire vStart;
  reg [11:0] HDL_Counter_out1;  // ufix12
  wire signed [17:0] Delay5_out1 [0:2];  // sfix18_En8 [3]
  wire signed [17:0] RGB3_0;  // sfix18_En8
  wire signed [17:0] RGB3_1;  // sfix18_En8
  wire signed [17:0] RGB3_2;  // sfix18_En8
  wire signed [17:0] RGB3 [0:2];  // sfix18_En8 [3]
  reg signed [17:0] Delay5_bypass_delay [0:2];  // sfix18 [3]
  reg signed [17:0] Delay5_reg [0:2];  // sfix18 [3]
  wire signed [17:0] Delay5_bypass_delay_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay5_reg_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay4_out1 [0:2];  // sfix18_En8 [3]
  wire signed [17:0] RGB2_0;  // sfix18_En8
  wire signed [17:0] RGB2_1;  // sfix18_En8
  wire signed [17:0] RGB2_2;  // sfix18_En8
  wire signed [17:0] RGB2 [0:2];  // sfix18_En8 [3]
  reg signed [17:0] Delay4_bypass_delay [0:2];  // sfix18 [3]
  reg signed [17:0] Delay4_reg [0:2];  // sfix18 [3]
  wire signed [17:0] Delay4_bypass_delay_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay4_reg_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay1_out1 [0:2];  // sfix18_En8 [3]
  wire signed [17:0] RGB1_0;  // sfix18_En8
  wire signed [17:0] RGB1_1;  // sfix18_En8
  wire signed [17:0] RGB1_2;  // sfix18_En8
  wire signed [17:0] RGB1 [0:2];  // sfix18_En8 [3]
  reg signed [17:0] Delay1_bypass_delay [0:2];  // sfix18 [3]
  reg signed [17:0] Delay1_reg [0:2];  // sfix18 [3]
  wire signed [17:0] Delay1_bypass_delay_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay1_reg_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay_out1 [0:2];  // sfix18_En8 [3]
  wire signed [17:0] RGB0_0;  // sfix18_En8
  wire signed [17:0] RGB0_1;  // sfix18_En8
  wire signed [17:0] RGB0_2;  // sfix18_En8
  wire signed [17:0] RGB0 [0:2];  // sfix18_En8 [3]
  reg signed [17:0] Delay_bypass_delay [0:2];  // sfix18 [3]
  reg signed [17:0] Delay_reg [0:2];  // sfix18 [3]
  wire signed [17:0] Delay_bypass_delay_next [0:2];  // sfix18_En8 [3]
  wire signed [17:0] Delay_reg_next [0:2];  // sfix18_En8 [3]


  assign valid = Ctrl_valid;

  assign vStart = Ctrl_vStart;

  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 12'b000000000000;
      end
      else begin
        if (enb && vStart) begin
          HDL_Counter_out1 <= HDL_Counter_out1 + 12'b000000000001;
        end
      end
    end



  assign RGB3[0] = RGB3_0;
  assign RGB3[1] = RGB3_1;
  assign RGB3[2] = RGB3_2;

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_bypass_delay[0] <= 18'sb000000000000000000;
        Delay5_bypass_delay[1] <= 18'sb000000000000000000;
        Delay5_bypass_delay[2] <= 18'sb000000000000000000;
        Delay5_reg[0] <= 18'sb000000000000000000;
        Delay5_reg[1] <= 18'sb000000000000000000;
        Delay5_reg[2] <= 18'sb000000000000000000;
      end
      else begin
        if (enb && valid) begin
          Delay5_bypass_delay[0] <= Delay5_bypass_delay_next[0];
          Delay5_bypass_delay[1] <= Delay5_bypass_delay_next[1];
          Delay5_bypass_delay[2] <= Delay5_bypass_delay_next[2];
          Delay5_reg[0] <= Delay5_reg_next[0];
          Delay5_reg[1] <= Delay5_reg_next[1];
          Delay5_reg[2] <= Delay5_reg_next[2];
        end
      end
    end

  assign Delay5_out1[0] = (valid == 1'b1 ? Delay5_reg[0] :
              Delay5_bypass_delay[0]);
  assign Delay5_out1[1] = (valid == 1'b1 ? Delay5_reg[1] :
              Delay5_bypass_delay[1]);
  assign Delay5_out1[2] = (valid == 1'b1 ? Delay5_reg[2] :
              Delay5_bypass_delay[2]);
  assign Delay5_bypass_delay_next[0] = Delay5_reg[0];
  assign Delay5_bypass_delay_next[1] = Delay5_reg[1];
  assign Delay5_bypass_delay_next[2] = Delay5_reg[2];
  assign Delay5_reg_next[0] = RGB3[0];
  assign Delay5_reg_next[1] = RGB3[1];
  assign Delay5_reg_next[2] = RGB3[2];



  assign RGB2[0] = RGB2_0;
  assign RGB2[1] = RGB2_1;
  assign RGB2[2] = RGB2_2;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_bypass_delay[0] <= 18'sb000000000000000000;
        Delay4_bypass_delay[1] <= 18'sb000000000000000000;
        Delay4_bypass_delay[2] <= 18'sb000000000000000000;
        Delay4_reg[0] <= 18'sb000000000000000000;
        Delay4_reg[1] <= 18'sb000000000000000000;
        Delay4_reg[2] <= 18'sb000000000000000000;
      end
      else begin
        if (enb && valid) begin
          Delay4_bypass_delay[0] <= Delay4_bypass_delay_next[0];
          Delay4_bypass_delay[1] <= Delay4_bypass_delay_next[1];
          Delay4_bypass_delay[2] <= Delay4_bypass_delay_next[2];
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
          Delay4_reg[2] <= Delay4_reg_next[2];
        end
      end
    end

  assign Delay4_out1[0] = (valid == 1'b1 ? Delay4_reg[0] :
              Delay4_bypass_delay[0]);
  assign Delay4_out1[1] = (valid == 1'b1 ? Delay4_reg[1] :
              Delay4_bypass_delay[1]);
  assign Delay4_out1[2] = (valid == 1'b1 ? Delay4_reg[2] :
              Delay4_bypass_delay[2]);
  assign Delay4_bypass_delay_next[0] = Delay4_reg[0];
  assign Delay4_bypass_delay_next[1] = Delay4_reg[1];
  assign Delay4_bypass_delay_next[2] = Delay4_reg[2];
  assign Delay4_reg_next[0] = RGB2[0];
  assign Delay4_reg_next[1] = RGB2[1];
  assign Delay4_reg_next[2] = RGB2[2];



  assign RGB1[0] = RGB1_0;
  assign RGB1[1] = RGB1_1;
  assign RGB1[2] = RGB1_2;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_bypass_delay[0] <= 18'sb000000000000000000;
        Delay1_bypass_delay[1] <= 18'sb000000000000000000;
        Delay1_bypass_delay[2] <= 18'sb000000000000000000;
        Delay1_reg[0] <= 18'sb000000000000000000;
        Delay1_reg[1] <= 18'sb000000000000000000;
        Delay1_reg[2] <= 18'sb000000000000000000;
      end
      else begin
        if (enb && valid) begin
          Delay1_bypass_delay[0] <= Delay1_bypass_delay_next[0];
          Delay1_bypass_delay[1] <= Delay1_bypass_delay_next[1];
          Delay1_bypass_delay[2] <= Delay1_bypass_delay_next[2];
          Delay1_reg[0] <= Delay1_reg_next[0];
          Delay1_reg[1] <= Delay1_reg_next[1];
          Delay1_reg[2] <= Delay1_reg_next[2];
        end
      end
    end

  assign Delay1_out1[0] = (valid == 1'b1 ? Delay1_reg[0] :
              Delay1_bypass_delay[0]);
  assign Delay1_out1[1] = (valid == 1'b1 ? Delay1_reg[1] :
              Delay1_bypass_delay[1]);
  assign Delay1_out1[2] = (valid == 1'b1 ? Delay1_reg[2] :
              Delay1_bypass_delay[2]);
  assign Delay1_bypass_delay_next[0] = Delay1_reg[0];
  assign Delay1_bypass_delay_next[1] = Delay1_reg[1];
  assign Delay1_bypass_delay_next[2] = Delay1_reg[2];
  assign Delay1_reg_next[0] = RGB1[0];
  assign Delay1_reg_next[1] = RGB1[1];
  assign Delay1_reg_next[2] = RGB1[2];



  Segmentat_ip_src_MATLAB_Function u_MATLAB_Function (.vstart(Ctrl_vStart),
                                                      .fr_num(HDL_Counter_out1),  // ufix12
                                                      .addr(K_addr),  // ufix2
                                                      .rgb_0(RGB_pixel_0),  // sfix18_En8
                                                      .rgb_1(RGB_pixel_1),  // sfix18_En8
                                                      .rgb_2(RGB_pixel_2),  // sfix18_En8
                                                      .rgb0_0(Delay_out1[0]),  // sfix18_En8
                                                      .rgb0_1(Delay_out1[1]),  // sfix18_En8
                                                      .rgb0_2(Delay_out1[2]),  // sfix18_En8
                                                      .rgb1_0(Delay1_out1[0]),  // sfix18_En8
                                                      .rgb1_1(Delay1_out1[1]),  // sfix18_En8
                                                      .rgb1_2(Delay1_out1[2]),  // sfix18_En8
                                                      .rgb2_0(Delay4_out1[0]),  // sfix18_En8
                                                      .rgb2_1(Delay4_out1[1]),  // sfix18_En8
                                                      .rgb2_2(Delay4_out1[2]),  // sfix18_En8
                                                      .rgb3_0(Delay5_out1[0]),  // sfix18_En8
                                                      .rgb3_1(Delay5_out1[1]),  // sfix18_En8
                                                      .rgb3_2(Delay5_out1[2]),  // sfix18_En8
                                                      .RGB0_0_1(RGB0_0),  // sfix18_En8
                                                      .RGB0_1_1(RGB0_1),  // sfix18_En8
                                                      .RGB0_2_1(RGB0_2),  // sfix18_En8
                                                      .RGB1_0_1(RGB1_0),  // sfix18_En8
                                                      .RGB1_1_1(RGB1_1),  // sfix18_En8
                                                      .RGB1_2_1(RGB1_2),  // sfix18_En8
                                                      .RGB2_0_1(RGB2_0),  // sfix18_En8
                                                      .RGB2_1_1(RGB2_1),  // sfix18_En8
                                                      .RGB2_2_1(RGB2_2),  // sfix18_En8
                                                      .RGB3_0_1(RGB3_0),  // sfix18_En8
                                                      .RGB3_1_1(RGB3_1),  // sfix18_En8
                                                      .RGB3_2_1(RGB3_2)  // sfix18_En8
                                                      );

  assign RGB0[0] = RGB0_0;
  assign RGB0[1] = RGB0_1;
  assign RGB0[2] = RGB0_2;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_bypass_delay[0] <= 18'sb000000000000000000;
        Delay_bypass_delay[1] <= 18'sb000000000000000000;
        Delay_bypass_delay[2] <= 18'sb000000000000000000;
        Delay_reg[0] <= 18'sb000000000000000000;
        Delay_reg[1] <= 18'sb000000000000000000;
        Delay_reg[2] <= 18'sb000000000000000000;
      end
      else begin
        if (enb && valid) begin
          Delay_bypass_delay[0] <= Delay_bypass_delay_next[0];
          Delay_bypass_delay[1] <= Delay_bypass_delay_next[1];
          Delay_bypass_delay[2] <= Delay_bypass_delay_next[2];
          Delay_reg[0] <= Delay_reg_next[0];
          Delay_reg[1] <= Delay_reg_next[1];
          Delay_reg[2] <= Delay_reg_next[2];
        end
      end
    end

  assign Delay_out1[0] = (valid == 1'b1 ? Delay_reg[0] :
              Delay_bypass_delay[0]);
  assign Delay_out1[1] = (valid == 1'b1 ? Delay_reg[1] :
              Delay_bypass_delay[1]);
  assign Delay_out1[2] = (valid == 1'b1 ? Delay_reg[2] :
              Delay_bypass_delay[2]);
  assign Delay_bypass_delay_next[0] = Delay_reg[0];
  assign Delay_bypass_delay_next[1] = Delay_reg[1];
  assign Delay_bypass_delay_next[2] = Delay_reg[2];
  assign Delay_reg_next[0] = RGB0[0];
  assign Delay_reg_next[1] = RGB0[1];
  assign Delay_reg_next[2] = RGB0[2];



  assign K_out_0 = Delay_out1[0];

  assign K_out_1 = Delay_out1[1];

  assign K_out_2 = Delay_out1[2];

  assign K_out_3 = Delay1_out1[0];

  assign K_out_4 = Delay1_out1[1];

  assign K_out_5 = Delay1_out1[2];

  assign K_out_6 = Delay4_out1[0];

  assign K_out_7 = Delay4_out1[1];

  assign K_out_8 = Delay4_out1[2];

  assign K_out_9 = Delay5_out1[0];

  assign K_out_10 = Delay5_out1[1];

  assign K_out_11 = Delay5_out1[2];

endmodule  // Segmentat_ip_src_Clustering

