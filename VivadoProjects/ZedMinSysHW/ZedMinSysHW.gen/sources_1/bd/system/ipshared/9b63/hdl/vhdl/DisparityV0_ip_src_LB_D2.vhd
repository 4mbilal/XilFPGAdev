-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Disparity_CT\DisparityV0_ip_src_LB_D2.vhd
-- Created: 2021-04-25 08:29:30
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DisparityV0_ip_src_LB_D2
-- Source Path: Disparity_CT/DisparityV0/ct/LB_D2
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DisparityV0_ip_src_DisparityV0_pkg.ALL;

ENTITY DisparityV0_ip_src_LB_D2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        In_rsvd                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        LB                                :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        D                                 :   OUT   vector_of_std_logic_vector8(0 TO 8)  -- uint8 [9]
        );
END DisparityV0_ip_src_LB_D2;


ARCHITECTURE rtl OF DisparityV0_ip_src_LB_D2 IS

  -- Component Declarations
  COMPONENT DisparityV0_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : DisparityV0_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.DisparityV0_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL In_unsigned                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Tapped_Delay_reg                 : vector_of_unsigned8(0 TO 7);  -- ufix8 [8]
  SIGNAL Tapped_Delay_out1                : vector_of_unsigned8(0 TO 8);  -- uint8 [9]
  SIGNAL Tapped_Delay_out1_0              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Line_Buffer_Horiz1_regin         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Line_Buffer_Horiz1_waddr         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Line_Buffer_Horiz1_wrenb         : std_logic;  -- ufix1
  SIGNAL Line_Buffer_Horiz1_raddr         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Line_Buffer_Horiz1_regout        : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Line_Buffer_Horiz1_regout_unsigned : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Line_Buffer_Horiz1_out1          : unsigned(7 DOWNTO 0);  -- uint8

BEGIN
  u_ShiftRegisterRAM : DisparityV0_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 8
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(Line_Buffer_Horiz1_regin),
              wr_addr => std_logic_vector(Line_Buffer_Horiz1_waddr),
              wr_en => Line_Buffer_Horiz1_wrenb,  -- ufix1
              rd_addr => std_logic_vector(Line_Buffer_Horiz1_raddr),
              rd_dout => Line_Buffer_Horiz1_regout
              );

  In_unsigned <= unsigned(In_rsvd);

  Tapped_Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Tapped_Delay_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Tapped_Delay_reg(7) <= In_unsigned;
        Tapped_Delay_reg(0 TO 6) <= Tapped_Delay_reg(1 TO 7);
      END IF;
    END IF;
  END PROCESS Tapped_Delay_process;

  Tapped_Delay_out1(0 TO 7) <= Tapped_Delay_reg(0 TO 7);
  Tapped_Delay_out1(8) <= In_unsigned;

  Tapped_Delay_out1_0 <= Tapped_Delay_out1(0);

  -- Input register for RAM-based shift register Line Buffer Horiz1
  Line_Buffer_Horiz1_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Line_Buffer_Horiz1_regin <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Line_Buffer_Horiz1_regin <= Tapped_Delay_out1_0;
      END IF;
    END IF;
  END PROCESS Line_Buffer_Horiz1_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 629
  -- 
  -- Write address counter for RAM-based shift register Line Buffer Horiz1
  Line_Buffer_Horiz1_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Line_Buffer_Horiz1_waddr <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Line_Buffer_Horiz1_waddr >= to_unsigned(16#275#, 10) THEN 
          Line_Buffer_Horiz1_waddr <= to_unsigned(16#000#, 10);
        ELSE 
          Line_Buffer_Horiz1_waddr <= Line_Buffer_Horiz1_waddr + to_unsigned(16#001#, 10);
        END IF;
      END IF;
    END IF;
  END PROCESS Line_Buffer_Horiz1_wr_process;


  Line_Buffer_Horiz1_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 629
  -- 
  -- Read address counter for RAM-based shift register Line Buffer Horiz1
  Line_Buffer_Horiz1_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Line_Buffer_Horiz1_raddr <= to_unsigned(16#001#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Line_Buffer_Horiz1_raddr >= to_unsigned(16#275#, 10) THEN 
          Line_Buffer_Horiz1_raddr <= to_unsigned(16#000#, 10);
        ELSE 
          Line_Buffer_Horiz1_raddr <= Line_Buffer_Horiz1_raddr + to_unsigned(16#001#, 10);
        END IF;
      END IF;
    END IF;
  END PROCESS Line_Buffer_Horiz1_rd_process;


  Line_Buffer_Horiz1_regout_unsigned <= unsigned(Line_Buffer_Horiz1_regout);

  -- Output register for RAM-based shift register Line Buffer Horiz1
  Line_Buffer_Horiz1_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Line_Buffer_Horiz1_out1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Line_Buffer_Horiz1_out1 <= Line_Buffer_Horiz1_regout_unsigned;
      END IF;
    END IF;
  END PROCESS Line_Buffer_Horiz1_regoutc_process;


  LB <= std_logic_vector(Line_Buffer_Horiz1_out1);

  outputgen: FOR k IN 0 TO 8 GENERATE
    D(k) <= std_logic_vector(Tapped_Delay_out1(k));
  END GENERATE;

END rtl;

