// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\BilateralFilterIP\Bilateral_ip_src_LineInfoStore_block.v
// Created: 2021-04-16 01:15:52
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Bilateral_ip_src_LineInfoStore_block
// Source Path: BilateralFilterIP/BilateralFilter_HW/Bilateral Filter1/LineBuffer/LineInfoStore
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Bilateral_ip_src_LineInfoStore_block
          (clk,
           reset,
           enb,
           hStartIn,
           hEndIn,
           vEndIn,
           validIn,
           dumpControl,
           preProcess,
           PrePadFlag,
           OnLineFlag,
           PostPadFlag,
           DumpingFlag,
           BlankingFlag,
           hStartOut,
           hEndOut,
           vEndOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   hStartIn;
  input   hEndIn;
  input   vEndIn;
  input   validIn;
  input   dumpControl;
  input   preProcess;
  output  PrePadFlag;
  output  OnLineFlag;
  output  PostPadFlag;
  output  DumpingFlag;
  output  BlankingFlag;
  output  hStartOut;
  output  hEndOut;
  output  vEndOut;
  output  validOut;


  wire validTemp1;
  wire validTemp2;
  reg  hStartFirstTap;
  reg  [0:3] intdelay_reg;  // ufix1 [4]
  wire [0:3] intdelay_reg_next;  // ufix1 [4]
  wire hStartFinalTap;
  reg  hEndFirstTap;
  reg  [0:2] intdelay_reg_1;  // ufix1 [3]
  wire [0:2] intdelay_reg_next_1;  // ufix1 [3]
  wire hEndCentreTap;
  reg  [0:4] intdelay_reg_2;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_2;  // ufix1 [5]
  wire hEndFinalTap;
  reg  [0:3] intdelay_reg_3;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_3;  // ufix1 [4]
  reg  [0:3] intdelay_reg_4;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_4;  // ufix1 [4]
  wire validTap;
  wire validGate1;
  wire notPreProcess;
  wire validGate2;
  wire validGate3;
  wire validGate4;


  assign validTemp1 = validIn | dumpControl;



  assign validTemp2 = hEndIn | validTemp1;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        hStartFirstTap <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          hStartFirstTap <= hStartIn;
        end
      end
    end



  assign PrePadFlag = hStartFirstTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
        end
      end
    end

  assign hStartFinalTap = intdelay_reg[3];
  assign intdelay_reg_next[0] = hStartFirstTap;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];



  assign OnLineFlag = hStartFinalTap;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        hEndFirstTap <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          hEndFirstTap <= hEndIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
        end
      end
    end

  assign hEndCentreTap = intdelay_reg_1[2];
  assign intdelay_reg_next_1[0] = hEndFirstTap;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];



  assign PostPadFlag = hEndCentreTap;

  assign DumpingFlag = hEndFirstTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
        intdelay_reg_2[4] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
          intdelay_reg_2[4] <= intdelay_reg_next_2[4];
        end
      end
    end

  assign hEndFinalTap = intdelay_reg_2[4];
  assign intdelay_reg_next_2[0] = hEndCentreTap;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];
  assign intdelay_reg_next_2[4] = intdelay_reg_2[3];



  assign BlankingFlag = hEndFinalTap;

  assign hStartOut = hStartFinalTap;

  assign hEndOut = hEndCentreTap;

  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
        intdelay_reg_3[3] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
          intdelay_reg_3[3] <= intdelay_reg_next_3[3];
        end
      end
    end

  assign vEndOut = intdelay_reg_3[3];
  assign intdelay_reg_next_3[0] = vEndIn;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];
  assign intdelay_reg_next_3[3] = intdelay_reg_3[2];



  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
        intdelay_reg_4[3] <= 1'b0;
      end
      else begin
        if (enb && validTemp2) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
          intdelay_reg_4[3] <= intdelay_reg_next_4[3];
        end
      end
    end

  assign validTap = intdelay_reg_4[3];
  assign intdelay_reg_next_4[0] = validIn;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];
  assign intdelay_reg_next_4[3] = intdelay_reg_4[2];



  assign validGate1 = hStartFirstTap & validTap;



  assign notPreProcess =  ~ preProcess;



  assign validGate2 = validTap & notPreProcess;



  assign validGate3 = validGate1 | validGate2;



  assign validGate4 = hStartFinalTap | validGate3;



  assign validOut = validGate4;

endmodule  // Bilateral_ip_src_LineInfoStore_block

