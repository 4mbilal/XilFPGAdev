// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\HSG\HSG_IP_src_Edge_Detector.v
// Created: 2018-10-21 17:42:58
// 
// Generated by MATLAB 9.3 and HDL Coder 3.11
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HSG_IP_src_Edge_Detector
// Source Path: HSG/HSG/Edge Detector
// Hierarchy Level: 1
// 
// Edge Detector
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HSG_IP_src_Edge_Detector
          (clk,
           reset,
           enb,
           in0,
           in1_hStart,
           in1_hEnd,
           in1_vStart,
           in1_vEnd,
           in1_valid,
           out0,
           out1,
           out2_hStart,
           out2_hEnd,
           out2_vStart,
           out2_vEnd,
           out2_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] in0;  // uint8
  input   in1_hStart;
  input   in1_hEnd;
  input   in1_vStart;
  input   in1_vEnd;
  input   in1_valid;
  output  signed [10:0] out0;  // sfix11_En3
  output  signed [10:0] out1;  // sfix11_En3
  output  out2_hStart;
  output  out2_hEnd;
  output  out2_vStart;
  output  out2_vEnd;
  output  out2_valid;

  wire [7:0] LMKDataOut_0;  // uint8
  wire [7:0] LMKDataOut_1;  // uint8
  wire [7:0] LMKDataOut_2;  // uint8
  wire LMKhStartOut;
  wire LMKhEndOut;
  wire LMKvStartOut;
  wire LMKvEndOut;
  wire LMKvalidOut;
  wire LMKShiftEnb;
  reg  [0:4] intdelay_reg;  // ufix1 [5]
  wire [0:4] intdelay_reg_next;  // ufix1 [5]
  wire validOutDelay;
  wire signed [10:0] const_zero;  // sfix11_En3
  wire signed [10:0] gradcomp1;  // sfix11_En3
  wire signed [10:0] gradcomp2;  // sfix11_En3
  wire signed [10:0] g1OutNext;  // sfix11_En3
  reg signed [10:0] Grad1;  // sfix11_En3
  wire signed [10:0] g2OutNext;  // sfix11_En3
  reg signed [10:0] Grad2;  // sfix11_En3
  reg  [0:4] intdelay_reg_1;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_1;  // ufix1 [5]
  wire hStartOutDelay;
  wire hsNext;
  reg  hStartOut;
  reg  [0:4] intdelay_reg_2;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_2;  // ufix1 [5]
  wire hEndOutDelay;
  wire heNext;
  reg  hEndOut;
  reg  [0:4] intdelay_reg_3;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_3;  // ufix1 [5]
  wire vStartOutDelay;
  wire vsNext;
  reg  vStartOut;
  reg  [0:4] intdelay_reg_4;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_4;  // ufix1 [5]
  wire vEndOutDelay;
  wire veNext;
  reg  vEndOut;
  reg  validOut;


  HSG_IP_src_LineBuffer u_LineBuffer (.clk(clk),
                                      .reset(reset),
                                      .enb(enb),
                                      .dataIn(in0),  // uint8
                                      .hStartIn(in1_hStart),
                                      .hEndIn(in1_hEnd),
                                      .vStartIn(in1_vStart),
                                      .vEndIn(in1_vEnd),
                                      .validIn(in1_valid),
                                      .dataOut_0(LMKDataOut_0),  // uint8
                                      .dataOut_1(LMKDataOut_1),  // uint8
                                      .dataOut_2(LMKDataOut_2),  // uint8
                                      .hStartOut(LMKhStartOut),
                                      .hEndOut(LMKhEndOut),
                                      .vStartOut(LMKvStartOut),
                                      .vEndOut(LMKvEndOut),
                                      .validOut(LMKvalidOut),
                                      .processDataOut(LMKShiftEnb)
                                      );

  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
        intdelay_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
          intdelay_reg[4] <= intdelay_reg_next[4];
        end
      end
    end

  assign validOutDelay = intdelay_reg[4];
  assign intdelay_reg_next[0] = LMKvalidOut;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];
  assign intdelay_reg_next[4] = intdelay_reg[3];



  assign const_zero = 11'sb00000000000;



  HSG_IP_src_SobelCore u_SobelCoreNet_inst (.clk(clk),
                                            .reset(reset),
                                            .enb(enb),
                                            .pixelInVec_0(LMKDataOut_0),  // uint8
                                            .pixelInVec_1(LMKDataOut_1),  // uint8
                                            .pixelInVec_2(LMKDataOut_2),  // uint8
                                            .ShiftEnb(LMKShiftEnb),
                                            .Gv(gradcomp1),  // sfix11_En3
                                            .Gh(gradcomp2)  // sfix11_En3
                                            );

  assign g1OutNext = (validOutDelay == 1'b0 ? const_zero :
              gradcomp1);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        Grad1 <= 11'sb00000000000;
      end
      else begin
        if (enb) begin
          Grad1 <= g1OutNext;
        end
      end
    end



  assign out0 = Grad1;

  assign g2OutNext = (validOutDelay == 1'b0 ? const_zero :
              gradcomp2);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        Grad2 <= 11'sb00000000000;
      end
      else begin
        if (enb) begin
          Grad2 <= g2OutNext;
        end
      end
    end



  assign out1 = Grad2;

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
        intdelay_reg_1[3] <= 1'b0;
        intdelay_reg_1[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
          intdelay_reg_1[3] <= intdelay_reg_next_1[3];
          intdelay_reg_1[4] <= intdelay_reg_next_1[4];
        end
      end
    end

  assign hStartOutDelay = intdelay_reg_1[4];
  assign intdelay_reg_next_1[0] = LMKhStartOut;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];
  assign intdelay_reg_next_1[3] = intdelay_reg_1[2];
  assign intdelay_reg_next_1[4] = intdelay_reg_1[3];



  assign hsNext = validOutDelay & hStartOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        hStartOut <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartOut <= hsNext;
        end
      end
    end



  assign out2_hStart = hStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
        intdelay_reg_2[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
          intdelay_reg_2[4] <= intdelay_reg_next_2[4];
        end
      end
    end

  assign hEndOutDelay = intdelay_reg_2[4];
  assign intdelay_reg_next_2[0] = LMKhEndOut;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];
  assign intdelay_reg_next_2[4] = intdelay_reg_2[3];



  assign heNext = validOutDelay & hEndOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        hEndOut <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndOut <= heNext;
        end
      end
    end



  assign out2_hEnd = hEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
        intdelay_reg_3[3] <= 1'b0;
        intdelay_reg_3[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
          intdelay_reg_3[3] <= intdelay_reg_next_3[3];
          intdelay_reg_3[4] <= intdelay_reg_next_3[4];
        end
      end
    end

  assign vStartOutDelay = intdelay_reg_3[4];
  assign intdelay_reg_next_3[0] = LMKvStartOut;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];
  assign intdelay_reg_next_3[3] = intdelay_reg_3[2];
  assign intdelay_reg_next_3[4] = intdelay_reg_3[3];



  assign vsNext = validOutDelay & vStartOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        vStartOut <= 1'b0;
      end
      else begin
        if (enb) begin
          vStartOut <= vsNext;
        end
      end
    end



  assign out2_vStart = vStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
        intdelay_reg_4[3] <= 1'b0;
        intdelay_reg_4[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
          intdelay_reg_4[3] <= intdelay_reg_next_4[3];
          intdelay_reg_4[4] <= intdelay_reg_next_4[4];
        end
      end
    end

  assign vEndOutDelay = intdelay_reg_4[4];
  assign intdelay_reg_next_4[0] = LMKvEndOut;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];
  assign intdelay_reg_next_4[3] = intdelay_reg_4[2];
  assign intdelay_reg_next_4[4] = intdelay_reg_4[3];



  assign veNext = validOutDelay & vEndOutDelay;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        vEndOut <= 1'b0;
      end
      else begin
        if (enb) begin
          vEndOut <= veNext;
        end
      end
    end



  assign out2_vEnd = vEndOut;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_6_process
      if (reset == 1'b1) begin
        validOut <= 1'b0;
      end
      else begin
        if (enb) begin
          validOut <= validOutDelay;
        end
      end
    end



  assign out2_valid = validOut;

endmodule  // HSG_IP_src_Edge_Detector

