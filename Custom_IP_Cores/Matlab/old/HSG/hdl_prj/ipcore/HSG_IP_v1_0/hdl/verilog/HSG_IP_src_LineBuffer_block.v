// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\HSG\HSG_IP_src_LineBuffer_block.v
// Created: 2018-10-21 17:42:58
// 
// Generated by MATLAB 9.3 and HDL Coder 3.11
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HSG_IP_src_LineBuffer_block
// Source Path: HSG/HSG/Image Filter/LineBuffer
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HSG_IP_src_LineBuffer_block
          (clk,
           reset,
           enb,
           dataIn,
           hStartIn,
           hEndIn,
           vStartIn,
           vEndIn,
           validIn,
           dataOut_0,
           dataOut_1,
           dataOut_2,
           dataOut_3,
           dataOut_4,
           dataOut_5,
           hStartOut,
           hEndOut,
           vStartOut,
           vEndOut,
           validOut,
           processDataOut);


  input   clk;
  input   reset;
  input   enb;
  input   dataIn;  // ufix1
  input   hStartIn;
  input   hEndIn;
  input   vStartIn;
  input   vEndIn;
  input   validIn;
  output  dataOut_0;  // ufix1
  output  dataOut_1;  // ufix1
  output  dataOut_2;  // ufix1
  output  dataOut_3;  // ufix1
  output  dataOut_4;  // ufix1
  output  dataOut_5;  // ufix1
  output  hStartOut;
  output  hEndOut;
  output  vStartOut;
  output  vEndOut;
  output  validOut;
  output  processDataOut;

  reg  [0:4] intdelay_reg;  // ufix1 [5]
  wire [0:4] intdelay_reg_next;  // ufix1 [5]
  wire inputREG;  // ufix1
  wire hStartV;
  wire hEndV;
  wire vStartV;
  wire vEndV;
  wire validInV;
  reg  [0:2] intdelay_reg_1;  // ufix1 [3]
  wire [0:2] intdelay_reg_next_1;  // ufix1 [3]
  wire hStartD;
  reg  [0:3] intdelay_reg_2;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_2;  // ufix1 [4]
  wire hEndD;
  reg  [0:2] intdelay_reg_3;  // ufix1 [3]
  wire [0:2] intdelay_reg_next_3;  // ufix1 [3]
  wire vStartD;
  reg  [0:2] intdelay_reg_4;  // ufix1 [3]
  wire [0:2] intdelay_reg_next_4;  // ufix1 [3]
  wire validInD;
  reg  [0:3] intdelay_reg_5;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_5;  // ufix1 [4]
  wire vEndD;
  wire unloadvalidOut;
  wire validTemp;
  wire [11:0] countLineSpaceOut;  // ufix12
  reg [11:0] countLineSpaceOutD;  // ufix12
  wire LineSpaceStoreEn;
  wire [11:0] lineSpaceAverage;  // ufix12
  wire lineSpaceLoad;
  wire lineSpaceEn;
  wire loadCache;
  wire [11:0] FIFOHandlerLineSpace;  // ufix12
  wire [7:0] loadPadCount;  // ufix8
  reg [7:0] loadPadCount_1;  // ufix8
  wire loadingFlag;
  reg  loadingFlagREG;
  reg  loadCacheD;
  wire hStartDataMem;
  reg  hStartREG;
  wire [5:0] lineMask;  // ufix6
  reg [5:0] lineMaskD;  // ufix6
  wire unloadvEndOut;
  reg  unloadvEndOut_1;
  wire unloadhEndOutD;
  wire hEndIn_1;
  wire unloadhStartOut;
  wire LineOut;
  reg  LineOutREG;
  wire [2:0] upperHalfPop;  // ufix3
  reg [2:0] upperHalfPop_1;  // ufix3
  wire [5:0] popFIFO;  // ufix6
  reg [5:0] popFIFO_1;  // ufix6
  wire [5:0] pushFIFO;  // ufix6
  reg [5:0] pushFIFO_1;  // ufix6
  wire InitializeFlag;
  wire DATA1;  // ufix1
  wire DATA2;  // ufix1
  wire DATA3;  // ufix1
  wire DATA4;  // ufix1
  wire DATA5;  // ufix1
  wire DATA6;  // ufix1
  wire allLineStart;
  wire allNextLineStart;
  wire allFIFOEmpty;
  wire [2:0] halfLoaded;  // ufix3
  wire vEndFlag;
  wire enableDataCacheOut;
  wire unloadingDelayedOut;
  wire runOrUnload;
  wire validOut_1;
  wire delayedvStartOut;
  wire Unloading;
  wire hStartIn_1;
  wire hStartCache;
  wire hEndCache;
  wire vStartCache;
  wire vEndCache;
  wire validCache;
  wire hStartFlag;
  wire hEndFlag;
  wire vStartFlag;
  wire unloadSEL;
  reg  [0:1] intdelay_reg_6;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_6;  // ufix1 [2]
  wire hEndCacheD;
  wire hEndCacheIn;
  wire validS;
  wire validPipeOut;
  wire preProcessFlag;
  wire postProcessFlag;
  wire validTempIn;
  reg  [0:1] intdelay_reg_7;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_7;  // ufix1 [2]
  wire validTempInD;
  reg  [0:1] intdelay_reg_8;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_8;  // ufix1 [2]
  wire preProcessFlag_1;
  reg  [0:1] reg_reg;  // ufix1 [2]
  wire [0:1] reg_reg_next;  // ufix1 [2]
  wire postProcessFlag_1;
  wire postProcessFlag_2;
  reg  unloadingDelayedOutREG;
  wire [2:0] horMUXSEL;  // ufix3
  wire [2:0] verMUXSEL;  // ufix3
  wire hStartOut_1;
  wire hEndOut_1;
  wire hStartOut_2;
  wire hStartOut_3;
  wire hStartOut_4;
  wire processDataOutS;
  reg  [0:3] intdelay_reg_9;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_9;  // ufix1 [4]
  wire processDataOutS_1;
  wire constLOW;  // ufix1
  reg  [0:1] intdelay_reg_10;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_10;  // ufix1 [2]
  wire horDataIn;  // ufix1
  reg [2:0] horMUXSELREG;  // ufix3
  wire dataHor1;  // ufix1
  wire dataHor2;  // ufix1
  wire dataHor3;  // ufix1
  wire dataHor4;  // ufix1
  wire dataHor5;  // ufix1
  wire dataHor6;  // ufix1
  wire dataHor7;  // ufix1
  wire dataVer1;  // ufix1
  wire dataVer2;  // ufix1
  wire dataVer3;  // ufix1
  wire dataVer4;  // ufix1
  wire dataVer5;  // ufix1
  wire dataVer6;  // ufix1
  wire dataREGIn1;  // ufix1
  reg  dataVer1_1;  // ufix1
  wire dataREGIn2;  // ufix1
  reg  dataVer2_1;  // ufix1
  wire dataREGIn3;  // ufix1
  reg  dataVer3_1;  // ufix1
  wire dataREGIn4;  // ufix1
  reg  dataVer4_1;  // ufix1
  wire dataREGIn5;  // ufix1
  reg  dataVer5_1;  // ufix1
  wire dataREGIn6;  // ufix1
  reg  dataVer6_1;  // ufix1
  reg  [0:4] intdelay_reg_11;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_11;  // ufix1 [5]
  reg  [0:4] intdelay_reg_12;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_12;  // ufix1 [5]
  reg  [0:4] intdelay_reg_13;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_13;  // ufix1 [5]
  reg  [0:4] intdelay_reg_14;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_14;  // ufix1 [5]
  reg  [0:4] intdelay_reg_15;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_15;  // ufix1 [5]
  reg  [0:4] intdelay_reg_16;  // ufix1 [5]
  wire [0:4] intdelay_reg_next_16;  // ufix1 [5]


  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
        intdelay_reg[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
          intdelay_reg[4] <= intdelay_reg_next[4];
        end
      end
    end

  assign inputREG = intdelay_reg[4];
  assign intdelay_reg_next[0] = dataIn;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];
  assign intdelay_reg_next[4] = intdelay_reg[3];



  HSG_IP_src_InputControlValidation_block u_INPUT_CONTROL_VALIDATION (.clk(clk),
                                                                      .reset(reset),
                                                                      .enb(enb),
                                                                      .hStartIn(hStartIn),
                                                                      .hEndIn(hEndIn),
                                                                      .vStartIn(vStartIn),
                                                                      .vEndIn(vEndIn),
                                                                      .validIn(validIn),
                                                                      .hStartOut(hStartV),
                                                                      .hEndOut(hEndV),
                                                                      .vStartOut(vStartV),
                                                                      .vEndOut(vEndV),
                                                                      .validOut(validInV)
                                                                      );

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
        end
      end
    end

  assign hStartD = intdelay_reg_1[2];
  assign intdelay_reg_next_1[0] = hStartV;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
        end
      end
    end

  assign hEndD = intdelay_reg_2[3];
  assign intdelay_reg_next_2[0] = hEndV;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];



  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
        end
      end
    end

  assign vStartD = intdelay_reg_3[2];
  assign intdelay_reg_next_3[0] = vStartV;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];



  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
        end
      end
    end

  assign validInD = intdelay_reg_4[2];
  assign intdelay_reg_next_4[0] = validInV;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];



  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        intdelay_reg_5[0] <= 1'b0;
        intdelay_reg_5[1] <= 1'b0;
        intdelay_reg_5[2] <= 1'b0;
        intdelay_reg_5[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_5[0] <= intdelay_reg_next_5[0];
          intdelay_reg_5[1] <= intdelay_reg_next_5[1];
          intdelay_reg_5[2] <= intdelay_reg_next_5[2];
          intdelay_reg_5[3] <= intdelay_reg_next_5[3];
        end
      end
    end

  assign vEndD = intdelay_reg_5[3];
  assign intdelay_reg_next_5[0] = vEndV;
  assign intdelay_reg_next_5[1] = intdelay_reg_5[0];
  assign intdelay_reg_next_5[2] = intdelay_reg_5[1];
  assign intdelay_reg_next_5[3] = intdelay_reg_5[2];



  assign validTemp = unloadvalidOut | validInD;



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        countLineSpaceOutD <= 12'b000000000000;
      end
      else begin
        if (enb) begin
          countLineSpaceOutD <= countLineSpaceOut;
        end
      end
    end



  HSG_IP_src_lineSpaceAverager_block u_LINE_SPACE_AVERAGER (.clk(clk),
                                                            .reset(reset),
                                                            .enb(enb),
                                                            .lineSpace(countLineSpaceOutD),  // ufix12
                                                            .lineCountEn(LineSpaceStoreEn),
                                                            .lineSpaceAverage(lineSpaceAverage)  // ufix12
                                                            );

  HSG_IP_src_lineSpaceStore_block u_LINE_SPACE_STORE (.clk(clk),
                                                      .reset(reset),
                                                      .enb(enb),
                                                      .lineSpaceAverageIn(lineSpaceAverage),  // ufix12
                                                      .lineSpaceLoad(lineSpaceLoad),
                                                      .lineSpaceEn(lineSpaceEn),
                                                      .Initialize(loadCache),
                                                      .lineSpace(FIFOHandlerLineSpace)  // ufix12
                                                      );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        loadPadCount_1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          loadPadCount_1 <= loadPadCount;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        loadingFlagREG <= 1'b0;
      end
      else begin
        if (enb) begin
          loadingFlagREG <= loadingFlag;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        loadCacheD <= 1'b0;
      end
      else begin
        if (enb) begin
          loadCacheD <= loadCache;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        hStartREG <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartREG <= hStartDataMem;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        lineMaskD <= 6'b000000;
      end
      else begin
        if (enb) begin
          lineMaskD <= lineMask;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_6_process
      if (reset == 1'b1) begin
        unloadvEndOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          unloadvEndOut_1 <= unloadvEndOut;
        end
      end
    end



  assign hEndIn_1 = unloadhEndOutD | hEndD;



  assign hStartDataMem = hStartD | unloadhStartOut;



  HSG_IP_src_dataReadFSM_block u_DATA_READ_FSM (.clk(clk),
                                                .reset(reset),
                                                .enb(enb),
                                                .hStartIn(hStartDataMem),
                                                .hEndIn(hEndIn_1),
                                                .vStartIn(vStartD),
                                                .vEndIn(unloadvEndOut_1),
                                                .validIn(validInD),
                                                .countLineSpaceOut(countLineSpaceOut),  // ufix12
                                                .LineSpaceStoreEn(LineSpaceStoreEn),
                                                .LineOut(LineOut)
                                                );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_7_process
      if (reset == 1'b1) begin
        LineOutREG <= 1'b0;
      end
      else begin
        if (enb) begin
          LineOutREG <= LineOut;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_8_process
      if (reset == 1'b1) begin
        upperHalfPop_1 <= 3'b000;
      end
      else begin
        if (enb) begin
          upperHalfPop_1 <= upperHalfPop;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_9_process
      if (reset == 1'b1) begin
        popFIFO_1 <= 6'b000000;
      end
      else begin
        if (enb) begin
          popFIFO_1 <= popFIFO;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_10_process
      if (reset == 1'b1) begin
        pushFIFO_1 <= 6'b000000;
      end
      else begin
        if (enb) begin
          pushFIFO_1 <= pushFIFO;
        end
      end
    end



  HSG_IP_src_DataMemory_block u_DATA_MEMORY (.clk(clk),
                                             .reset(reset),
                                             .enb(enb),
                                             .dataIn(inputREG),  // ufix1
                                             .pushFIFO(pushFIFO_1),  // ufix6
                                             .popFIFO(popFIFO_1),  // ufix6
                                             .upperPop(upperHalfPop_1),  // ufix3
                                             .lineIn(LineOutREG),
                                             .lineMask(lineMaskD),  // ufix6
                                             .hStartIn(hStartREG),
                                             .load(loadCacheD),
                                             .loadingFlag(loadingFlagREG),
                                             .InitializeFlag(InitializeFlag),
                                             .LoadingPaddingCount(loadPadCount_1),  // ufix8
                                             .dataOut1(DATA1),  // ufix1
                                             .dataOut2(DATA2),  // ufix1
                                             .dataOut3(DATA3),  // ufix1
                                             .dataOut4(DATA4),  // ufix1
                                             .dataOut5(DATA5),  // ufix1
                                             .dataOut6(DATA6),  // ufix1
                                             .allLineStart(allLineStart),
                                             .allNextLineStart(allNextLineStart),
                                             .allFIFOEmpty(allFIFOEmpty),
                                             .halfLoaded(halfLoaded)  // ufix3
                                             );

  HSG_IP_src_FIFOHandlerFSM_block u_FIFO_HANDLER (.clk(clk),
                                                  .reset(reset),
                                                  .enb(enb),
                                                  .allLineStart(allLineStart),
                                                  .hStartIn(hStartD),
                                                  .vEndIn(vEndD),
                                                  .validIn(validInD),
                                                  .lineSpaceAverageIn(FIFOHandlerLineSpace),  // ufix12
                                                  .allNextLineStart(allNextLineStart),
                                                  .vEndFlag(vEndFlag),
                                                  .allFIFOEmpty(allFIFOEmpty),
                                                  .vStartIn(vStartD),
                                                  .hEndIn(hEndD),
                                                  .halfLoaded(halfLoaded),  // ufix3
                                                  .pushFIFO(pushFIFO),  // ufix6
                                                  .popFIFO(popFIFO),  // ufix6
                                                  .upperPop(upperHalfPop),  // ufix3
                                                  .InitializeFlag(InitializeFlag),
                                                  .enableDataCacheOut(enableDataCacheOut),
                                                  .unloadhStartOut(unloadhStartOut),
                                                  .unloadhEndOut(unloadhEndOutD),
                                                  .unloadvEndOut(unloadvEndOut),
                                                  .unloadValidOut(unloadvalidOut),
                                                  .unloadingDelayedOut(unloadingDelayedOut),
                                                  .lineMaskOut(lineMask),  // ufix6
                                                  .runOrUnload(runOrUnload),
                                                  .validOut(validOut_1),
                                                  .delayedVStartOut(delayedvStartOut),
                                                  .load(loadCache),
                                                  .loadingFlag(loadingFlag),
                                                  .Unloading(Unloading),
                                                  .lineSpaceLoad(lineSpaceLoad),
                                                  .lineSpaceEn(lineSpaceEn),
                                                  .loadCount(loadPadCount)  // ufix8
                                                  );

  assign hStartIn_1 = unloadhStartOut | hStartD;



  HSG_IP_src_controlCache_block u_CONTROL_CACHE (.clk(clk),
                                                 .reset(reset),
                                                 .enb(enb),
                                                 .hStartIn(hStartIn_1),
                                                 .hEndIn(hEndIn_1),
                                                 .vStartIn(delayedvStartOut),
                                                 .vEndIn(unloadvEndOut),
                                                 .validIn(validTemp),
                                                 .load(loadCache),
                                                 .dataEnable(enableDataCacheOut),
                                                 .Unloading(Unloading),
                                                 .hStartOut(hStartCache),
                                                 .hEndOut(hEndCache),
                                                 .vStartOut(vStartCache),
                                                 .vEndOut(vEndCache),
                                                 .validOut(validCache),
                                                 .hStartFlag(hStartFlag),
                                                 .hEndFlag(hEndFlag),
                                                 .vStartFlag(vStartFlag),
                                                 .vEndFlag(vEndFlag),
                                                 .Unloading_1(unloadSEL)
                                                 );

  always @(posedge clk or posedge reset)
    begin : intdelay_6_process
      if (reset == 1'b1) begin
        intdelay_reg_6[0] <= 1'b0;
        intdelay_reg_6[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_6[0] <= intdelay_reg_next_6[0];
          intdelay_reg_6[1] <= intdelay_reg_next_6[1];
        end
      end
    end

  assign hEndCacheD = intdelay_reg_6[1];
  assign intdelay_reg_next_6[0] = hEndCache;
  assign intdelay_reg_next_6[1] = intdelay_reg_6[0];



  assign hEndCacheIn = (unloadSEL == 1'b0 ? hEndCacheD :
              hEndCache);



  assign validS = unloadvalidOut | validOut_1;



  HSG_IP_src_validPipeline_block u_VALID_PIPELINE (.clk(clk),
                                                   .reset(reset),
                                                   .enb(enb),
                                                   .validIn(validS),
                                                   .validPipeOut(validPipeOut),
                                                   .preProcessFlag(preProcessFlag),
                                                   .postProcessFlag(postProcessFlag)
                                                   );

  assign validTempIn = runOrUnload & validPipeOut;



  always @(posedge clk or posedge reset)
    begin : intdelay_7_process
      if (reset == 1'b1) begin
        intdelay_reg_7[0] <= 1'b0;
        intdelay_reg_7[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_7[0] <= intdelay_reg_next_7[0];
          intdelay_reg_7[1] <= intdelay_reg_next_7[1];
        end
      end
    end

  assign validTempInD = intdelay_reg_7[1];
  assign intdelay_reg_next_7[0] = validTempIn;
  assign intdelay_reg_next_7[1] = intdelay_reg_7[0];



  always @(posedge clk or posedge reset)
    begin : intdelay_8_process
      if (reset == 1'b1) begin
        intdelay_reg_8[0] <= 1'b0;
        intdelay_reg_8[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_8[0] <= intdelay_reg_next_8[0];
          intdelay_reg_8[1] <= intdelay_reg_next_8[1];
        end
      end
    end

  assign preProcessFlag_1 = intdelay_reg_8[1];
  assign intdelay_reg_next_8[0] = preProcessFlag;
  assign intdelay_reg_next_8[1] = intdelay_reg_8[0];



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_11_process
      if (reset == 1'b1) begin
        reg_reg[0] <= 1'b0;
        reg_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          reg_reg[0] <= reg_reg_next[0];
          reg_reg[1] <= reg_reg_next[1];
        end
      end
    end

  assign postProcessFlag_1 = reg_reg[1];
  assign reg_reg_next[0] = postProcessFlag;
  assign reg_reg_next[1] = reg_reg[0];



  assign postProcessFlag_2 = (unloadSEL == 1'b0 ? postProcessFlag_1 :
              postProcessFlag_1);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_12_process
      if (reset == 1'b1) begin
        unloadingDelayedOutREG <= 1'b0;
      end
      else begin
        if (enb) begin
          unloadingDelayedOutREG <= unloadingDelayedOut;
        end
      end
    end



  HSG_IP_src_dataWriteFSM_block u_DATA_WRITE_FSM (.clk(clk),
                                                  .reset(reset),
                                                  .enb(enb),
                                                  .hStartIn(hStartCache),
                                                  .hEndIn(hEndCacheIn),
                                                  .vStartIn(vStartCache),
                                                  .vEndIn(vEndCache),
                                                  .validTempIn(validTempInD),
                                                  .preProcessFlag(preProcessFlag_1),
                                                  .postProcessFlag(postProcessFlag_2),
                                                  .hStartFlag(hStartFlag),
                                                  .vStartFlag(vStartFlag),
                                                  .hEndFlag(hEndFlag),
                                                  .unloadingD(unloadingDelayedOutREG),
                                                  .runOrUnload(runOrUnload),
                                                  .resetFIFO(loadCacheD),
                                                  .horMUXSEL(horMUXSEL),  // ufix3
                                                  .verMUXSEL(verMUXSEL),  // ufix3
                                                  .hStartOut(hStartOut_1),
                                                  .hEndOut(hEndOut_1),
                                                  .vStartOut(hStartOut_2),
                                                  .vEndOut(hStartOut_3),
                                                  .validOut(hStartOut_4),
                                                  .processDataOut(processDataOutS)
                                                  );

  always @(posedge clk or posedge reset)
    begin : intdelay_9_process
      if (reset == 1'b1) begin
        intdelay_reg_9[0] <= 1'b0;
        intdelay_reg_9[1] <= 1'b0;
        intdelay_reg_9[2] <= 1'b0;
        intdelay_reg_9[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_9[0] <= intdelay_reg_next_9[0];
          intdelay_reg_9[1] <= intdelay_reg_next_9[1];
          intdelay_reg_9[2] <= intdelay_reg_next_9[2];
          intdelay_reg_9[3] <= intdelay_reg_next_9[3];
        end
      end
    end

  assign processDataOutS_1 = intdelay_reg_9[3];
  assign intdelay_reg_next_9[0] = processDataOutS;
  assign intdelay_reg_next_9[1] = intdelay_reg_9[0];
  assign intdelay_reg_next_9[2] = intdelay_reg_9[1];
  assign intdelay_reg_next_9[3] = intdelay_reg_9[2];



  assign constLOW = 1'b0;



  always @(posedge clk or posedge reset)
    begin : intdelay_10_process
      if (reset == 1'b1) begin
        intdelay_reg_10[0] <= 1'b0;
        intdelay_reg_10[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_10[0] <= intdelay_reg_next_10[0];
          intdelay_reg_10[1] <= intdelay_reg_next_10[1];
        end
      end
    end

  assign horDataIn = intdelay_reg_10[1];
  assign intdelay_reg_next_10[0] = inputREG;
  assign intdelay_reg_next_10[1] = intdelay_reg_10[0];



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_13_process
      if (reset == 1'b1) begin
        horMUXSELREG <= 3'b000;
      end
      else begin
        if (enb) begin
          horMUXSELREG <= horMUXSEL;
        end
      end
    end



  HSG_IP_src_horizontalMux_block u_HORIZONTAL_MULTIPLEXING (.clk(clk),
                                                            .reset(reset),
                                                            .enb(enb),
                                                            .dataIn1(horDataIn),  // ufix1
                                                            .dataIn2(DATA1),  // ufix1
                                                            .dataIn3(DATA2),  // ufix1
                                                            .dataIn4(DATA3),  // ufix1
                                                            .dataIn5(DATA4),  // ufix1
                                                            .dataIn6(DATA5),  // ufix1
                                                            .dataIn7(DATA6),  // ufix1
                                                            .unloadSEL(unloadSEL),
                                                            .horMUXSEL(horMUXSELREG),  // ufix3
                                                            .dataOut1(dataHor1),  // ufix1
                                                            .dataOut2(dataHor2),  // ufix1
                                                            .dataOut3(dataHor3),  // ufix1
                                                            .dataOut4(dataHor4),  // ufix1
                                                            .dataOut5(dataHor5),  // ufix1
                                                            .dataOut6(dataHor6),  // ufix1
                                                            .dataOut7(dataHor7)  // ufix1
                                                            );

  HSG_IP_src_verticalMux_block u_VERTICAL_MULTIPLEXING (.clk(clk),
                                                        .reset(reset),
                                                        .enb(enb),
                                                        .dataIn1(dataHor1),  // ufix1
                                                        .dataIn2(dataHor2),  // ufix1
                                                        .dataIn3(dataHor3),  // ufix1
                                                        .dataIn4(dataHor4),  // ufix1
                                                        .dataIn5(dataHor5),  // ufix1
                                                        .dataIn6(dataHor6),  // ufix1
                                                        .dataIn7(dataHor7),  // ufix1
                                                        .verMuxSEL(verMUXSEL),  // ufix3
                                                        .dataOut1(dataVer1),  // ufix1
                                                        .dataOut2(dataVer2),  // ufix1
                                                        .dataOut3(dataVer3),  // ufix1
                                                        .dataOut4(dataVer4),  // ufix1
                                                        .dataOut5(dataVer5),  // ufix1
                                                        .dataOut6(dataVer6)  // ufix1
                                                        );

  assign dataREGIn1 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer1);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_14_process
      if (reset == 1'b1) begin
        dataVer1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer1_1 <= dataREGIn1;
        end
      end
    end



  assign dataOut_0 = dataVer1_1;

  assign dataREGIn2 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer2);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_15_process
      if (reset == 1'b1) begin
        dataVer2_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer2_1 <= dataREGIn2;
        end
      end
    end



  assign dataOut_1 = dataVer2_1;

  assign dataREGIn3 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer3);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_16_process
      if (reset == 1'b1) begin
        dataVer3_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer3_1 <= dataREGIn3;
        end
      end
    end



  assign dataOut_2 = dataVer3_1;

  assign dataREGIn4 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer4);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_17_process
      if (reset == 1'b1) begin
        dataVer4_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer4_1 <= dataREGIn4;
        end
      end
    end



  assign dataOut_3 = dataVer4_1;

  assign dataREGIn5 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer5);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_18_process
      if (reset == 1'b1) begin
        dataVer5_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer5_1 <= dataREGIn5;
        end
      end
    end



  assign dataOut_4 = dataVer5_1;

  assign dataREGIn6 = (processDataOutS_1 == 1'b0 ? constLOW :
              dataVer6);



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_19_process
      if (reset == 1'b1) begin
        dataVer6_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          dataVer6_1 <= dataREGIn6;
        end
      end
    end



  assign dataOut_5 = dataVer6_1;

  always @(posedge clk or posedge reset)
    begin : intdelay_11_process
      if (reset == 1'b1) begin
        intdelay_reg_11[0] <= 1'b0;
        intdelay_reg_11[1] <= 1'b0;
        intdelay_reg_11[2] <= 1'b0;
        intdelay_reg_11[3] <= 1'b0;
        intdelay_reg_11[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_11[0] <= intdelay_reg_next_11[0];
          intdelay_reg_11[1] <= intdelay_reg_next_11[1];
          intdelay_reg_11[2] <= intdelay_reg_next_11[2];
          intdelay_reg_11[3] <= intdelay_reg_next_11[3];
          intdelay_reg_11[4] <= intdelay_reg_next_11[4];
        end
      end
    end

  assign hStartOut = intdelay_reg_11[4];
  assign intdelay_reg_next_11[0] = hStartOut_1;
  assign intdelay_reg_next_11[1] = intdelay_reg_11[0];
  assign intdelay_reg_next_11[2] = intdelay_reg_11[1];
  assign intdelay_reg_next_11[3] = intdelay_reg_11[2];
  assign intdelay_reg_next_11[4] = intdelay_reg_11[3];



  always @(posedge clk or posedge reset)
    begin : intdelay_12_process
      if (reset == 1'b1) begin
        intdelay_reg_12[0] <= 1'b0;
        intdelay_reg_12[1] <= 1'b0;
        intdelay_reg_12[2] <= 1'b0;
        intdelay_reg_12[3] <= 1'b0;
        intdelay_reg_12[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_12[0] <= intdelay_reg_next_12[0];
          intdelay_reg_12[1] <= intdelay_reg_next_12[1];
          intdelay_reg_12[2] <= intdelay_reg_next_12[2];
          intdelay_reg_12[3] <= intdelay_reg_next_12[3];
          intdelay_reg_12[4] <= intdelay_reg_next_12[4];
        end
      end
    end

  assign hEndOut = intdelay_reg_12[4];
  assign intdelay_reg_next_12[0] = hEndOut_1;
  assign intdelay_reg_next_12[1] = intdelay_reg_12[0];
  assign intdelay_reg_next_12[2] = intdelay_reg_12[1];
  assign intdelay_reg_next_12[3] = intdelay_reg_12[2];
  assign intdelay_reg_next_12[4] = intdelay_reg_12[3];



  always @(posedge clk or posedge reset)
    begin : intdelay_13_process
      if (reset == 1'b1) begin
        intdelay_reg_13[0] <= 1'b0;
        intdelay_reg_13[1] <= 1'b0;
        intdelay_reg_13[2] <= 1'b0;
        intdelay_reg_13[3] <= 1'b0;
        intdelay_reg_13[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_13[0] <= intdelay_reg_next_13[0];
          intdelay_reg_13[1] <= intdelay_reg_next_13[1];
          intdelay_reg_13[2] <= intdelay_reg_next_13[2];
          intdelay_reg_13[3] <= intdelay_reg_next_13[3];
          intdelay_reg_13[4] <= intdelay_reg_next_13[4];
        end
      end
    end

  assign vStartOut = intdelay_reg_13[4];
  assign intdelay_reg_next_13[0] = hStartOut_2;
  assign intdelay_reg_next_13[1] = intdelay_reg_13[0];
  assign intdelay_reg_next_13[2] = intdelay_reg_13[1];
  assign intdelay_reg_next_13[3] = intdelay_reg_13[2];
  assign intdelay_reg_next_13[4] = intdelay_reg_13[3];



  always @(posedge clk or posedge reset)
    begin : intdelay_14_process
      if (reset == 1'b1) begin
        intdelay_reg_14[0] <= 1'b0;
        intdelay_reg_14[1] <= 1'b0;
        intdelay_reg_14[2] <= 1'b0;
        intdelay_reg_14[3] <= 1'b0;
        intdelay_reg_14[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_14[0] <= intdelay_reg_next_14[0];
          intdelay_reg_14[1] <= intdelay_reg_next_14[1];
          intdelay_reg_14[2] <= intdelay_reg_next_14[2];
          intdelay_reg_14[3] <= intdelay_reg_next_14[3];
          intdelay_reg_14[4] <= intdelay_reg_next_14[4];
        end
      end
    end

  assign vEndOut = intdelay_reg_14[4];
  assign intdelay_reg_next_14[0] = hStartOut_3;
  assign intdelay_reg_next_14[1] = intdelay_reg_14[0];
  assign intdelay_reg_next_14[2] = intdelay_reg_14[1];
  assign intdelay_reg_next_14[3] = intdelay_reg_14[2];
  assign intdelay_reg_next_14[4] = intdelay_reg_14[3];



  always @(posedge clk or posedge reset)
    begin : intdelay_15_process
      if (reset == 1'b1) begin
        intdelay_reg_15[0] <= 1'b0;
        intdelay_reg_15[1] <= 1'b0;
        intdelay_reg_15[2] <= 1'b0;
        intdelay_reg_15[3] <= 1'b0;
        intdelay_reg_15[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_15[0] <= intdelay_reg_next_15[0];
          intdelay_reg_15[1] <= intdelay_reg_next_15[1];
          intdelay_reg_15[2] <= intdelay_reg_next_15[2];
          intdelay_reg_15[3] <= intdelay_reg_next_15[3];
          intdelay_reg_15[4] <= intdelay_reg_next_15[4];
        end
      end
    end

  assign validOut = intdelay_reg_15[4];
  assign intdelay_reg_next_15[0] = hStartOut_4;
  assign intdelay_reg_next_15[1] = intdelay_reg_15[0];
  assign intdelay_reg_next_15[2] = intdelay_reg_15[1];
  assign intdelay_reg_next_15[3] = intdelay_reg_15[2];
  assign intdelay_reg_next_15[4] = intdelay_reg_15[3];



  always @(posedge clk or posedge reset)
    begin : intdelay_16_process
      if (reset == 1'b1) begin
        intdelay_reg_16[0] <= 1'b0;
        intdelay_reg_16[1] <= 1'b0;
        intdelay_reg_16[2] <= 1'b0;
        intdelay_reg_16[3] <= 1'b0;
        intdelay_reg_16[4] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_16[0] <= intdelay_reg_next_16[0];
          intdelay_reg_16[1] <= intdelay_reg_next_16[1];
          intdelay_reg_16[2] <= intdelay_reg_next_16[2];
          intdelay_reg_16[3] <= intdelay_reg_next_16[3];
          intdelay_reg_16[4] <= intdelay_reg_next_16[4];
        end
      end
    end

  assign processDataOut = intdelay_reg_16[4];
  assign intdelay_reg_next_16[0] = processDataOutS;
  assign intdelay_reg_next_16[1] = intdelay_reg_16[0];
  assign intdelay_reg_next_16[2] = intdelay_reg_16[1];
  assign intdelay_reg_next_16[3] = intdelay_reg_16[2];
  assign intdelay_reg_next_16[4] = intdelay_reg_16[3];



endmodule  // HSG_IP_src_LineBuffer_block

