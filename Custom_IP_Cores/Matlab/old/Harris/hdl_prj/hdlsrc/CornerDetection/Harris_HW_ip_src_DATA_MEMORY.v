// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CornerDetection\Harris_HW_ip_src_DATA_MEMORY.v
// Created: 2020-01-15 11:28:56
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Harris_HW_ip_src_DATA_MEMORY
// Source Path: CornerDetection/Harris_HW/HDL Corner Algorithm/Gradients/Gradx/LineBuffer/DATA_MEMORY
// Hierarchy Level: 5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Harris_HW_ip_src_DATA_MEMORY
          (clk,
           reset,
           enb,
           Unloading,
           pixelIn,
           hStartIn,
           hEndIn,
           vStartIn,
           vEndIn,
           validIn,
           popEn,
           dataVectorOut_0,
           dataVectorOut_1,
           dataVectorOut_2,
           popOut,
           AllAtEnd);


  input   clk;
  input   reset;
  input   enb;
  input   Unloading;
  input   [7:0] pixelIn;  // uint8
  input   hStartIn;
  input   hEndIn;
  input   vStartIn;
  input   vEndIn;
  input   validIn;
  input   [1:0] popEn;  // ufix2
  output  [7:0] dataVectorOut_0;  // uint8
  output  [7:0] dataVectorOut_1;  // uint8
  output  [7:0] dataVectorOut_2;  // uint8
  output  popOut;
  output  AllAtEnd;


  reg [7:0] intdelay_reg [0:2];  // ufix8 [3]
  wire [7:0] intdelay_reg_next [0:2];  // ufix8 [3]
  wire [7:0] pixelColumn_0;  // uint8
  reg [7:0] pixelColumnO1;  // uint8
  reg  validREG;
  reg  unloadPop;
  reg  hEndREG;
  reg  hEndREGT;
  wire unloadPopT;
  wire validPop;
  wire PopEnSL;
  wire [9:0] writeAddr1;  // ufix10
  wire pushFIFO2;
  wire [9:0] readAddr2;  // ufix10
  wire popFIFO_2;
  wire EndofLine1;
  wire [7:0] pixelColumn1;  // uint8
  wire PopEnSL_1;
  wire [9:0] writeAddr2;  // ufix10
  wire pushFIFO3;
  wire [9:0] readAddr3;  // ufix10
  wire popFIFO_3;
  wire EndofLine2;
  reg [9:0] writeAddrREG2;  // ufix10
  reg  pushOutREG2;
  wire [7:0] pixelColumn2;  // uint8
  reg  popOut_1;


  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 8'b00000000;
        intdelay_reg[1] <= 8'b00000000;
        intdelay_reg[2] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
        end
      end
    end

  assign pixelColumn_0 = intdelay_reg[2];
  assign intdelay_reg_next[0] = pixelIn;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        pixelColumnO1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          pixelColumnO1 <= pixelColumn_0;
        end
      end
    end



  assign dataVectorOut_0 = pixelColumnO1;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        validREG <= 1'b0;
      end
      else begin
        if (enb) begin
          validREG <= validIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        unloadPop <= 1'b0;
      end
      else begin
        if (enb) begin
          unloadPop <= validREG;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        hEndREG <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndREG <= hEndIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        hEndREGT <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndREGT <= hEndREG;
        end
      end
    end



  assign unloadPopT = hEndREGT & (unloadPop & Unloading);



  assign validPop = validREG | unloadPopT;



  assign PopEnSL = popEn[0];



  Harris_HW_ip_src_PushPopCounterOne u_PushPopCounterOne (.clk(clk),
                                                          .reset(reset),
                                                          .enb(enb),
                                                          .hStartIn(hStartIn),
                                                          .popIn(validPop),
                                                          .popEnable(PopEnSL),
                                                          .hEndIn(hEndREG),
                                                          .wrAddr(writeAddr1),  // ufix10
                                                          .pushOut(pushFIFO2),
                                                          .rdAddr(readAddr2),  // ufix10
                                                          .popOut(popFIFO_2),
                                                          .EndofLine(EndofLine1)
                                                          );

  Harris_HW_ip_src_SimpleDualPortRAM_generic #(.AddrWidth(10),
                                               .DataWidth(8)
                                               )
                                             u_SimpleDualPortRAM_Generic1 (.clk(clk),
                                                                           .enb(enb),
                                                                           .wr_din(pixelColumn_0),
                                                                           .wr_addr(writeAddr1),
                                                                           .wr_en(pushFIFO2),
                                                                           .rd_addr(readAddr2),
                                                                           .rd_dout(pixelColumn1)
                                                                           );

  assign dataVectorOut_1 = pixelColumn1;

  assign PopEnSL_1 = popEn[0];



  Harris_HW_ip_src_PushPopCounter u_PushPopCounter2 (.clk(clk),
                                                     .reset(reset),
                                                     .enb(enb),
                                                     .hStartIn(hStartIn),
                                                     .popIn(validPop),
                                                     .popEnable(PopEnSL_1),
                                                     .hEndIn(hEndREG),
                                                     .writeCountPrev(writeAddr1),  // ufix10
                                                     .wrAddr(writeAddr2),  // ufix10
                                                     .pushOut(pushFIFO3),
                                                     .rdAddr(readAddr3),  // ufix10
                                                     .popOut(popFIFO_3),
                                                     .EndofLine(EndofLine2)
                                                     );

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        writeAddrREG2 <= 10'b0000000000;
      end
      else begin
        if (enb) begin
          writeAddrREG2 <= writeAddr2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_6_process
      if (reset == 1'b1) begin
        pushOutREG2 <= 1'b0;
      end
      else begin
        if (enb) begin
          pushOutREG2 <= pushFIFO3;
        end
      end
    end



  Harris_HW_ip_src_SimpleDualPortRAM_generic #(.AddrWidth(10),
                                               .DataWidth(8)
                                               )
                                             u_SimpleDualPortRAM_Generic2 (.clk(clk),
                                                                           .enb(enb),
                                                                           .wr_din(pixelColumn1),
                                                                           .wr_addr(writeAddrREG2),
                                                                           .wr_en(pushOutREG2),
                                                                           .rd_addr(readAddr3),
                                                                           .rd_dout(pixelColumn2)
                                                                           );

  assign dataVectorOut_2 = pixelColumn2;

  always @(posedge clk or posedge reset)
    begin : reg_rsvd_7_process
      if (reset == 1'b1) begin
        popOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          popOut_1 <= popFIFO_2;
        end
      end
    end



  assign AllAtEnd = EndofLine1 & EndofLine2;



  assign popOut = popOut_1;

endmodule  // Harris_HW_ip_src_DATA_MEMORY

