// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\RGB2GrayIP\RGB2Gray_ip_src_RGB2INTENSITY.v
// Created: 2021-04-15 23:49:35
// 
// Generated by MATLAB 9.10 and HDL Coder 3.18
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: RGB2Gray_ip_src_RGB2INTENSITY
// Source Path: RGB2GrayIP/RGB2Gray_HW/Color Space Converter/RGB2INTENSITY
// Hierarchy Level: 2
// 
// RGB to Intensity Converter
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module RGB2Gray_ip_src_RGB2INTENSITY
          (clk,
           reset,
           enb,
           R,
           G,
           B,
           hStartIn,
           hEndIn,
           vStartIn,
           vEndIn,
           validIn,
           Intensity,
           hStartOut,
           hEndOut,
           vStartOut,
           vEndOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] R;  // uint8
  input   [7:0] G;  // uint8
  input   [7:0] B;  // uint8
  input   hStartIn;
  input   hEndIn;
  input   vStartIn;
  input   vEndIn;
  input   validIn;
  output  [7:0] Intensity;  // uint8
  output  hStartOut;
  output  hEndOut;
  output  vStartOut;
  output  vEndOut;
  output  validOut;


  reg  [0:6] intdelay_reg;  // ufix1 [7]
  wire [0:6] intdelay_reg_next;  // ufix1 [7]
  wire Mux_Sel;
  wire [7:0] const_zero;  // uint8
  reg [7:0] multiInDelay1_reg [0:1];  // ufix8 [2]
  wire [7:0] multiInDelay1_reg_next [0:1];  // ufix8 [2]
  wire [7:0] multiInReg1;  // uint8
  wire [23:0] multiOut1;  // ufix24_En16
  reg [23:0] multiOutDelay1_reg [0:1];  // ufix24 [2]
  wire [23:0] multiOutDelay1_reg_next [0:1];  // ufix24_En16 [2]
  wire [23:0] multiOutReg1;  // ufix24_En16
  reg [7:0] multiInDelay2_reg [0:1];  // ufix8 [2]
  wire [7:0] multiInDelay2_reg_next [0:1];  // ufix8 [2]
  wire [7:0] multiInReg2;  // uint8
  wire [23:0] multiOut2;  // ufix24_En16
  reg [23:0] multiOutDelay2_reg [0:1];  // ufix24 [2]
  wire [23:0] multiOutDelay2_reg_next [0:1];  // ufix24_En16 [2]
  wire [23:0] multiOutReg2;  // ufix24_En16
  wire [24:0] adder_add_cast;  // ufix25_En16
  wire [24:0] adder_add_cast_1;  // ufix25_En16
  wire [24:0] S1_up;  // ufix25_En16
  reg [24:0] S1_up_delay;  // ufix25_En16
  reg [7:0] multiInDelay3_reg [0:1];  // ufix8 [2]
  wire [7:0] multiInDelay3_reg_next [0:1];  // ufix8 [2]
  wire [7:0] multiInReg3;  // uint8
  wire [23:0] multiOut3;  // ufix24_En16
  reg [23:0] multiOutDelay3_reg [0:1];  // ufix24 [2]
  wire [23:0] multiOutDelay3_reg_next [0:1];  // ufix24_En16 [2]
  wire [23:0] multiOutReg3;  // ufix24_En16
  wire [24:0] S1_down_delay;  // ufix25_En16
  reg [24:0] S1_down_delay_1;  // ufix25_En16
  wire [25:0] adder_add_cast_2;  // ufix26_En16
  wire [25:0] adder_add_cast_3;  // ufix26_En16
  wire [25:0] S2;  // ufix26_En16
  reg [25:0] S2_delay;  // ufix26_En16
  wire [7:0] castout;  // uint8
  reg [7:0] cast_delay;  // uint8
  wire [7:0] SwitchOut;  // uint8
  reg [7:0] Intensity_1;  // uint8
  reg  [0:7] hStart_reg;  // ufix1 [8]
  wire [0:7] hStart_reg_next;  // ufix1 [8]
  reg  [0:7] hEnd_reg;  // ufix1 [8]
  wire [0:7] hEnd_reg_next;  // ufix1 [8]
  reg  [0:7] vStart_reg;  // ufix1 [8]
  wire [0:7] vStart_reg_next;  // ufix1 [8]
  reg  [0:7] vEnd_reg;  // ufix1 [8]
  wire [0:7] vEnd_reg_next;  // ufix1 [8]
  reg  validOut_1;


  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
        intdelay_reg[2] <= 1'b0;
        intdelay_reg[3] <= 1'b0;
        intdelay_reg[4] <= 1'b0;
        intdelay_reg[5] <= 1'b0;
        intdelay_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
          intdelay_reg[4] <= intdelay_reg_next[4];
          intdelay_reg[5] <= intdelay_reg_next[5];
          intdelay_reg[6] <= intdelay_reg_next[6];
        end
      end
    end

  assign Mux_Sel = intdelay_reg[6];
  assign intdelay_reg_next[0] = validIn;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];
  assign intdelay_reg_next[4] = intdelay_reg[3];
  assign intdelay_reg_next[5] = intdelay_reg[4];
  assign intdelay_reg_next[6] = intdelay_reg[5];



  assign const_zero = 8'b00000000;



  always @(posedge clk or posedge reset)
    begin : multiInDelay1_process
      if (reset == 1'b1) begin
        multiInDelay1_reg[0] <= 8'b00000000;
        multiInDelay1_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          multiInDelay1_reg[0] <= multiInDelay1_reg_next[0];
          multiInDelay1_reg[1] <= multiInDelay1_reg_next[1];
        end
      end
    end

  assign multiInReg1 = multiInDelay1_reg[1];
  assign multiInDelay1_reg_next[0] = R;
  assign multiInDelay1_reg_next[1] = multiInDelay1_reg[0];



  assign multiOut1 = 16'b0100110010001011 * multiInReg1;



  always @(posedge clk or posedge reset)
    begin : multiOutDelay1_process
      if (reset == 1'b1) begin
        multiOutDelay1_reg[0] <= 24'b000000000000000000000000;
        multiOutDelay1_reg[1] <= 24'b000000000000000000000000;
      end
      else begin
        if (enb) begin
          multiOutDelay1_reg[0] <= multiOutDelay1_reg_next[0];
          multiOutDelay1_reg[1] <= multiOutDelay1_reg_next[1];
        end
      end
    end

  assign multiOutReg1 = multiOutDelay1_reg[1];
  assign multiOutDelay1_reg_next[0] = multiOut1;
  assign multiOutDelay1_reg_next[1] = multiOutDelay1_reg[0];



  always @(posedge clk or posedge reset)
    begin : multiInDelay2_process
      if (reset == 1'b1) begin
        multiInDelay2_reg[0] <= 8'b00000000;
        multiInDelay2_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          multiInDelay2_reg[0] <= multiInDelay2_reg_next[0];
          multiInDelay2_reg[1] <= multiInDelay2_reg_next[1];
        end
      end
    end

  assign multiInReg2 = multiInDelay2_reg[1];
  assign multiInDelay2_reg_next[0] = G;
  assign multiInDelay2_reg_next[1] = multiInDelay2_reg[0];



  assign multiOut2 = 16'b1001011001000110 * multiInReg2;



  always @(posedge clk or posedge reset)
    begin : multiOutDelay2_process
      if (reset == 1'b1) begin
        multiOutDelay2_reg[0] <= 24'b000000000000000000000000;
        multiOutDelay2_reg[1] <= 24'b000000000000000000000000;
      end
      else begin
        if (enb) begin
          multiOutDelay2_reg[0] <= multiOutDelay2_reg_next[0];
          multiOutDelay2_reg[1] <= multiOutDelay2_reg_next[1];
        end
      end
    end

  assign multiOutReg2 = multiOutDelay2_reg[1];
  assign multiOutDelay2_reg_next[0] = multiOut2;
  assign multiOutDelay2_reg_next[1] = multiOutDelay2_reg[0];



  assign adder_add_cast = {1'b0, multiOutReg1};
  assign adder_add_cast_1 = {1'b0, multiOutReg2};
  assign S1_up = adder_add_cast + adder_add_cast_1;



  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        S1_up_delay <= 25'b0000000000000000000000000;
      end
      else begin
        if (enb) begin
          S1_up_delay <= S1_up;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : multiInDelay3_process
      if (reset == 1'b1) begin
        multiInDelay3_reg[0] <= 8'b00000000;
        multiInDelay3_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          multiInDelay3_reg[0] <= multiInDelay3_reg_next[0];
          multiInDelay3_reg[1] <= multiInDelay3_reg_next[1];
        end
      end
    end

  assign multiInReg3 = multiInDelay3_reg[1];
  assign multiInDelay3_reg_next[0] = B;
  assign multiInDelay3_reg_next[1] = multiInDelay3_reg[0];



  assign multiOut3 = 16'b0001110100101111 * multiInReg3;



  always @(posedge clk or posedge reset)
    begin : multiOutDelay3_process
      if (reset == 1'b1) begin
        multiOutDelay3_reg[0] <= 24'b000000000000000000000000;
        multiOutDelay3_reg[1] <= 24'b000000000000000000000000;
      end
      else begin
        if (enb) begin
          multiOutDelay3_reg[0] <= multiOutDelay3_reg_next[0];
          multiOutDelay3_reg[1] <= multiOutDelay3_reg_next[1];
        end
      end
    end

  assign multiOutReg3 = multiOutDelay3_reg[1];
  assign multiOutDelay3_reg_next[0] = multiOut3;
  assign multiOutDelay3_reg_next[1] = multiOutDelay3_reg[0];



  assign S1_down_delay = {1'b0, multiOutReg3};



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        S1_down_delay_1 <= 25'b0000000000000000000000000;
      end
      else begin
        if (enb) begin
          S1_down_delay_1 <= S1_down_delay;
        end
      end
    end



  assign adder_add_cast_2 = {1'b0, S1_up_delay};
  assign adder_add_cast_3 = {1'b0, S1_down_delay_1};
  assign S2 = adder_add_cast_2 + adder_add_cast_3;



  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        S2_delay <= 26'b00000000000000000000000000;
      end
      else begin
        if (enb) begin
          S2_delay <= S2;
        end
      end
    end



  // convert dataOut to the data type of R, G, and B
  assign castout = ((S2_delay[25:24] != 2'b00) || (S2_delay[23:16] == 8'b11111111) ? 8'b11111111 :
              S2_delay[23:16] + S2_delay[15]);



  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        cast_delay <= 8'b00000000;
      end
      else begin
        if (enb) begin
          cast_delay <= castout;
        end
      end
    end



  assign SwitchOut = (Mux_Sel == 1'b0 ? const_zero :
              cast_delay);



  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        Intensity_1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Intensity_1 <= SwitchOut;
        end
      end
    end



  // delay hStart
  always @(posedge clk or posedge reset)
    begin : hStart_process
      if (reset == 1'b1) begin
        hStart_reg[0] <= 1'b0;
        hStart_reg[1] <= 1'b0;
        hStart_reg[2] <= 1'b0;
        hStart_reg[3] <= 1'b0;
        hStart_reg[4] <= 1'b0;
        hStart_reg[5] <= 1'b0;
        hStart_reg[6] <= 1'b0;
        hStart_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          hStart_reg[0] <= hStart_reg_next[0];
          hStart_reg[1] <= hStart_reg_next[1];
          hStart_reg[2] <= hStart_reg_next[2];
          hStart_reg[3] <= hStart_reg_next[3];
          hStart_reg[4] <= hStart_reg_next[4];
          hStart_reg[5] <= hStart_reg_next[5];
          hStart_reg[6] <= hStart_reg_next[6];
          hStart_reg[7] <= hStart_reg_next[7];
        end
      end
    end

  assign hStartOut = hStart_reg[7];
  assign hStart_reg_next[0] = hStartIn;
  assign hStart_reg_next[1] = hStart_reg[0];
  assign hStart_reg_next[2] = hStart_reg[1];
  assign hStart_reg_next[3] = hStart_reg[2];
  assign hStart_reg_next[4] = hStart_reg[3];
  assign hStart_reg_next[5] = hStart_reg[4];
  assign hStart_reg_next[6] = hStart_reg[5];
  assign hStart_reg_next[7] = hStart_reg[6];



  // delay hEnd
  always @(posedge clk or posedge reset)
    begin : hEnd_process
      if (reset == 1'b1) begin
        hEnd_reg[0] <= 1'b0;
        hEnd_reg[1] <= 1'b0;
        hEnd_reg[2] <= 1'b0;
        hEnd_reg[3] <= 1'b0;
        hEnd_reg[4] <= 1'b0;
        hEnd_reg[5] <= 1'b0;
        hEnd_reg[6] <= 1'b0;
        hEnd_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          hEnd_reg[0] <= hEnd_reg_next[0];
          hEnd_reg[1] <= hEnd_reg_next[1];
          hEnd_reg[2] <= hEnd_reg_next[2];
          hEnd_reg[3] <= hEnd_reg_next[3];
          hEnd_reg[4] <= hEnd_reg_next[4];
          hEnd_reg[5] <= hEnd_reg_next[5];
          hEnd_reg[6] <= hEnd_reg_next[6];
          hEnd_reg[7] <= hEnd_reg_next[7];
        end
      end
    end

  assign hEndOut = hEnd_reg[7];
  assign hEnd_reg_next[0] = hEndIn;
  assign hEnd_reg_next[1] = hEnd_reg[0];
  assign hEnd_reg_next[2] = hEnd_reg[1];
  assign hEnd_reg_next[3] = hEnd_reg[2];
  assign hEnd_reg_next[4] = hEnd_reg[3];
  assign hEnd_reg_next[5] = hEnd_reg[4];
  assign hEnd_reg_next[6] = hEnd_reg[5];
  assign hEnd_reg_next[7] = hEnd_reg[6];



  // delay vStart
  always @(posedge clk or posedge reset)
    begin : vStart_process
      if (reset == 1'b1) begin
        vStart_reg[0] <= 1'b0;
        vStart_reg[1] <= 1'b0;
        vStart_reg[2] <= 1'b0;
        vStart_reg[3] <= 1'b0;
        vStart_reg[4] <= 1'b0;
        vStart_reg[5] <= 1'b0;
        vStart_reg[6] <= 1'b0;
        vStart_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          vStart_reg[0] <= vStart_reg_next[0];
          vStart_reg[1] <= vStart_reg_next[1];
          vStart_reg[2] <= vStart_reg_next[2];
          vStart_reg[3] <= vStart_reg_next[3];
          vStart_reg[4] <= vStart_reg_next[4];
          vStart_reg[5] <= vStart_reg_next[5];
          vStart_reg[6] <= vStart_reg_next[6];
          vStart_reg[7] <= vStart_reg_next[7];
        end
      end
    end

  assign vStartOut = vStart_reg[7];
  assign vStart_reg_next[0] = vStartIn;
  assign vStart_reg_next[1] = vStart_reg[0];
  assign vStart_reg_next[2] = vStart_reg[1];
  assign vStart_reg_next[3] = vStart_reg[2];
  assign vStart_reg_next[4] = vStart_reg[3];
  assign vStart_reg_next[5] = vStart_reg[4];
  assign vStart_reg_next[6] = vStart_reg[5];
  assign vStart_reg_next[7] = vStart_reg[6];



  // delay vEnd
  always @(posedge clk or posedge reset)
    begin : vEnd_process
      if (reset == 1'b1) begin
        vEnd_reg[0] <= 1'b0;
        vEnd_reg[1] <= 1'b0;
        vEnd_reg[2] <= 1'b0;
        vEnd_reg[3] <= 1'b0;
        vEnd_reg[4] <= 1'b0;
        vEnd_reg[5] <= 1'b0;
        vEnd_reg[6] <= 1'b0;
        vEnd_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          vEnd_reg[0] <= vEnd_reg_next[0];
          vEnd_reg[1] <= vEnd_reg_next[1];
          vEnd_reg[2] <= vEnd_reg_next[2];
          vEnd_reg[3] <= vEnd_reg_next[3];
          vEnd_reg[4] <= vEnd_reg_next[4];
          vEnd_reg[5] <= vEnd_reg_next[5];
          vEnd_reg[6] <= vEnd_reg_next[6];
          vEnd_reg[7] <= vEnd_reg_next[7];
        end
      end
    end

  assign vEndOut = vEnd_reg[7];
  assign vEnd_reg_next[0] = vEndIn;
  assign vEnd_reg_next[1] = vEnd_reg[0];
  assign vEnd_reg_next[2] = vEnd_reg[1];
  assign vEnd_reg_next[3] = vEnd_reg[2];
  assign vEnd_reg_next[4] = vEnd_reg[3];
  assign vEnd_reg_next[5] = vEnd_reg[4];
  assign vEnd_reg_next[6] = vEnd_reg[5];
  assign vEnd_reg_next[7] = vEnd_reg[6];



  always @(posedge clk or posedge reset)
    begin : intdelay_6_process
      if (reset == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          validOut_1 <= Mux_Sel;
        end
      end
    end



  assign Intensity = Intensity_1;

  assign validOut = validOut_1;

endmodule  // RGB2Gray_ip_src_RGB2INTENSITY

