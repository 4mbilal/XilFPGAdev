// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CornerDetection\Harris_HW_ip_src_det_trace.v
// Created: 2020-01-15 11:28:57
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Harris_HW_ip_src_det_trace
// Source Path: CornerDetection/Harris_HW/HDL Corner Algorithm/det_trace
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Harris_HW_ip_src_det_trace
          (clk,
           reset,
           enb,
           Gy2,
           GyGx,
           Gx2,
           ctrl_hStart,
           ctrl_hEnd,
           ctrl_vStart,
           ctrl_vEnd,
           ctrl_valid,
           HarrisOut,
           ctrlOut_hStart,
           ctrlOut_hEnd,
           ctrlOut_vStart,
           ctrlOut_vEnd,
           ctrlOut_valid);


  input   clk;
  input   reset;
  input   enb;
  input   signed [17:0] Gy2;  // sfix18
  input   signed [17:0] GyGx;  // sfix18
  input   signed [17:0] Gx2;  // sfix18
  input   ctrl_hStart;
  input   ctrl_hEnd;
  input   ctrl_vStart;
  input   ctrl_vEnd;
  input   ctrl_valid;
  output  signed [37:0] HarrisOut;  // sfix38
  output  ctrlOut_hStart;
  output  ctrlOut_hEnd;
  output  ctrlOut_vStart;
  output  ctrlOut_vEnd;
  output  ctrlOut_valid;


  reg signed [17:0] Gy2_1;  // sfix18
  reg signed [17:0] Gy2_2;  // sfix18
  reg signed [17:0] Gx2_1;  // sfix18
  reg signed [17:0] Gx2_2;  // sfix18
  wire signed [35:0] Product4_out1;  // sfix36
  reg signed [35:0] Delay26_reg [0:1];  // sfix36 [2]
  wire signed [35:0] Delay26_reg_next [0:1];  // sfix36 [2]
  wire signed [35:0] Delay26_out1;  // sfix36
  reg signed [17:0] reduced_reg [0:1];  // sfix18 [2]
  wire signed [17:0] reduced_reg_next [0:1];  // sfix18 [2]
  wire signed [17:0] GyGx_1;  // sfix18
  wire signed [35:0] Product3_out1;  // sfix36
  reg signed [35:0] Delay25_reg [0:1];  // sfix36 [2]
  wire signed [35:0] Delay25_reg_next [0:1];  // sfix36 [2]
  wire signed [35:0] Delay25_out1;  // sfix36
  wire signed [36:0] Sum1_1;  // sfix37
  wire signed [36:0] Sum1_2;  // sfix37
  wire signed [36:0] Sum1_out1;  // sfix37
  reg signed [36:0] delayMatch_reg [0:4];  // sfix37 [5]
  wire signed [36:0] delayMatch_reg_next [0:4];  // sfix37 [5]
  wire signed [36:0] Delay33_out1;  // sfix37
  wire signed [17:0] Sum_out1;  // sfix18
  reg signed [17:0] Delay24_out1;  // sfix18
  reg signed [17:0] reduced_reg_1 [0:1];  // sfix18 [2]
  wire signed [17:0] reduced_reg_next_1 [0:1];  // sfix18 [2]
  wire signed [17:0] Delay24_out1_1;  // sfix18
  wire signed [35:0] Product5_out1;  // sfix36
  reg signed [35:0] HwModeRegister6_reg [0:2];  // sfix36 [3]
  wire signed [35:0] HwModeRegister6_reg_next [0:2];  // sfix36 [3]
  wire signed [35:0] Delay30_out1;  // sfix36
  wire [15:0] kconst;  // ufix16_En16
  reg [15:0] kconst_1;  // ufix16_En16
  wire signed [16:0] Gain_cast;  // sfix17_En16
  wire signed [52:0] Gain_mul_temp;  // sfix53_En16
  wire signed [51:0] Gain_cast_1;  // sfix52_En16
  wire signed [35:0] Gain_out1;  // sfix36
  reg signed [35:0] Delay32_reg [0:1];  // sfix36 [2]
  wire signed [35:0] Delay32_reg_next [0:1];  // sfix36 [2]
  wire signed [35:0] Delay32_out1;  // sfix36
  wire signed [37:0] Sum2_1;  // sfix38
  wire signed [37:0] Sum2_2;  // sfix38
  wire signed [37:0] Sum2_out1;  // sfix38
  reg signed [37:0] Delay34_out1;  // sfix38
  reg  [0:7] alpha_reg;  // ufix1 [8]
  wire [0:7] alpha_reg_next;  // ufix1 [8]
  wire Delay40_out1_hStart;
  reg  [0:7] alpha_reg_1;  // ufix1 [8]
  wire [0:7] alpha_reg_next_1;  // ufix1 [8]
  wire Delay40_out1_hEnd;
  reg  [0:7] alpha_reg_2;  // ufix1 [8]
  wire [0:7] alpha_reg_next_2;  // ufix1 [8]
  wire Delay40_out1_vStart;
  reg  [0:7] alpha_reg_3;  // ufix1 [8]
  wire [0:7] alpha_reg_next_3;  // ufix1 [8]
  wire Delay40_out1_vEnd;
  reg  [0:7] alpha_reg_4;  // ufix1 [8]
  wire [0:7] alpha_reg_next_4;  // ufix1 [8]
  wire Delay40_out1_valid;


  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        Gy2_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Gy2_1 <= Gy2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        Gy2_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Gy2_2 <= Gy2_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_2_process
      if (reset == 1'b1) begin
        Gx2_1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Gx2_1 <= Gx2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_3_process
      if (reset == 1'b1) begin
        Gx2_2 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Gx2_2 <= Gx2_1;
        end
      end
    end



  assign Product4_out1 = Gy2_2 * Gx2_2;



  always @(posedge clk or posedge reset)
    begin : Delay26_process
      if (reset == 1'b1) begin
        Delay26_reg[0] <= 36'sh000000000;
        Delay26_reg[1] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Delay26_reg[0] <= Delay26_reg_next[0];
          Delay26_reg[1] <= Delay26_reg_next[1];
        end
      end
    end

  assign Delay26_out1 = Delay26_reg[1];
  assign Delay26_reg_next[0] = Product4_out1;
  assign Delay26_reg_next[1] = Delay26_reg[0];



  always @(posedge clk or posedge reset)
    begin : reduced_4_process
      if (reset == 1'b1) begin
        reduced_reg[0] <= 18'sb000000000000000000;
        reduced_reg[1] <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg[0] <= reduced_reg_next[0];
          reduced_reg[1] <= reduced_reg_next[1];
        end
      end
    end

  assign GyGx_1 = reduced_reg[1];
  assign reduced_reg_next[0] = GyGx;
  assign reduced_reg_next[1] = reduced_reg[0];



  assign Product3_out1 = GyGx_1 * GyGx_1;



  always @(posedge clk or posedge reset)
    begin : Delay25_process
      if (reset == 1'b1) begin
        Delay25_reg[0] <= 36'sh000000000;
        Delay25_reg[1] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Delay25_reg[0] <= Delay25_reg_next[0];
          Delay25_reg[1] <= Delay25_reg_next[1];
        end
      end
    end

  assign Delay25_out1 = Delay25_reg[1];
  assign Delay25_reg_next[0] = Product3_out1;
  assign Delay25_reg_next[1] = Delay25_reg[0];



  assign Sum1_1 = {Delay26_out1[35], Delay26_out1};
  assign Sum1_2 = {Delay25_out1[35], Delay25_out1};
  assign Sum1_out1 = Sum1_1 - Sum1_2;



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 37'sh0000000000;
        delayMatch_reg[1] <= 37'sh0000000000;
        delayMatch_reg[2] <= 37'sh0000000000;
        delayMatch_reg[3] <= 37'sh0000000000;
        delayMatch_reg[4] <= 37'sh0000000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
        end
      end
    end

  assign Delay33_out1 = delayMatch_reg[4];
  assign delayMatch_reg_next[0] = Sum1_out1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];



  assign Sum_out1 = Gy2_1 + Gx2_1;



  always @(posedge clk or posedge reset)
    begin : Delay24_process
      if (reset == 1'b1) begin
        Delay24_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay24_out1 <= Sum_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reduced_5_process
      if (reset == 1'b1) begin
        reduced_reg_1[0] <= 18'sb000000000000000000;
        reduced_reg_1[1] <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          reduced_reg_1[0] <= reduced_reg_next_1[0];
          reduced_reg_1[1] <= reduced_reg_next_1[1];
        end
      end
    end

  assign Delay24_out1_1 = reduced_reg_1[1];
  assign reduced_reg_next_1[0] = Delay24_out1;
  assign reduced_reg_next_1[1] = reduced_reg_1[0];



  assign Product5_out1 = Delay24_out1_1 * Delay24_out1_1;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister6_process
      if (reset == 1'b1) begin
        HwModeRegister6_reg[0] <= 36'sh000000000;
        HwModeRegister6_reg[1] <= 36'sh000000000;
        HwModeRegister6_reg[2] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          HwModeRegister6_reg[0] <= HwModeRegister6_reg_next[0];
          HwModeRegister6_reg[1] <= HwModeRegister6_reg_next[1];
          HwModeRegister6_reg[2] <= HwModeRegister6_reg_next[2];
        end
      end
    end

  assign Delay30_out1 = HwModeRegister6_reg[2];
  assign HwModeRegister6_reg_next[0] = Product5_out1;
  assign HwModeRegister6_reg_next[1] = HwModeRegister6_reg[0];
  assign HwModeRegister6_reg_next[2] = HwModeRegister6_reg[1];



  assign kconst = 16'b0000101000111101;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister7_process
      if (reset == 1'b1) begin
        kconst_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          kconst_1 <= kconst;
        end
      end
    end



  assign Gain_cast = {1'b0, kconst_1};
  assign Gain_mul_temp = Delay30_out1 * Gain_cast;
  assign Gain_cast_1 = Gain_mul_temp[51:0];
  assign Gain_out1 = Gain_cast_1[51:16];



  always @(posedge clk or posedge reset)
    begin : Delay32_process
      if (reset == 1'b1) begin
        Delay32_reg[0] <= 36'sh000000000;
        Delay32_reg[1] <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Delay32_reg[0] <= Delay32_reg_next[0];
          Delay32_reg[1] <= Delay32_reg_next[1];
        end
      end
    end

  assign Delay32_out1 = Delay32_reg[1];
  assign Delay32_reg_next[0] = Gain_out1;
  assign Delay32_reg_next[1] = Delay32_reg[0];



  assign Sum2_1 = {Delay33_out1[36], Delay33_out1};
  assign Sum2_2 = {{2{Delay32_out1[35]}}, Delay32_out1};
  assign Sum2_out1 = Sum2_1 - Sum2_2;



  always @(posedge clk or posedge reset)
    begin : Delay34_process
      if (reset == 1'b1) begin
        Delay34_out1 <= 38'sh0000000000;
      end
      else begin
        if (enb) begin
          Delay34_out1 <= Sum2_out1;
        end
      end
    end



  assign HarrisOut = Delay34_out1;

  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        alpha_reg[0] <= 1'b0;
        alpha_reg[1] <= 1'b0;
        alpha_reg[2] <= 1'b0;
        alpha_reg[3] <= 1'b0;
        alpha_reg[4] <= 1'b0;
        alpha_reg[5] <= 1'b0;
        alpha_reg[6] <= 1'b0;
        alpha_reg[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg[0] <= alpha_reg_next[0];
          alpha_reg[1] <= alpha_reg_next[1];
          alpha_reg[2] <= alpha_reg_next[2];
          alpha_reg[3] <= alpha_reg_next[3];
          alpha_reg[4] <= alpha_reg_next[4];
          alpha_reg[5] <= alpha_reg_next[5];
          alpha_reg[6] <= alpha_reg_next[6];
          alpha_reg[7] <= alpha_reg_next[7];
        end
      end
    end

  assign Delay40_out1_hStart = alpha_reg[7];
  assign alpha_reg_next[0] = ctrl_hStart;
  assign alpha_reg_next[1] = alpha_reg[0];
  assign alpha_reg_next[2] = alpha_reg[1];
  assign alpha_reg_next[3] = alpha_reg[2];
  assign alpha_reg_next[4] = alpha_reg[3];
  assign alpha_reg_next[5] = alpha_reg[4];
  assign alpha_reg_next[6] = alpha_reg[5];
  assign alpha_reg_next[7] = alpha_reg[6];



  assign ctrlOut_hStart = Delay40_out1_hStart;

  always @(posedge clk or posedge reset)
    begin : c_1_process
      if (reset == 1'b1) begin
        alpha_reg_1[0] <= 1'b0;
        alpha_reg_1[1] <= 1'b0;
        alpha_reg_1[2] <= 1'b0;
        alpha_reg_1[3] <= 1'b0;
        alpha_reg_1[4] <= 1'b0;
        alpha_reg_1[5] <= 1'b0;
        alpha_reg_1[6] <= 1'b0;
        alpha_reg_1[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_1[0] <= alpha_reg_next_1[0];
          alpha_reg_1[1] <= alpha_reg_next_1[1];
          alpha_reg_1[2] <= alpha_reg_next_1[2];
          alpha_reg_1[3] <= alpha_reg_next_1[3];
          alpha_reg_1[4] <= alpha_reg_next_1[4];
          alpha_reg_1[5] <= alpha_reg_next_1[5];
          alpha_reg_1[6] <= alpha_reg_next_1[6];
          alpha_reg_1[7] <= alpha_reg_next_1[7];
        end
      end
    end

  assign Delay40_out1_hEnd = alpha_reg_1[7];
  assign alpha_reg_next_1[0] = ctrl_hEnd;
  assign alpha_reg_next_1[1] = alpha_reg_1[0];
  assign alpha_reg_next_1[2] = alpha_reg_1[1];
  assign alpha_reg_next_1[3] = alpha_reg_1[2];
  assign alpha_reg_next_1[4] = alpha_reg_1[3];
  assign alpha_reg_next_1[5] = alpha_reg_1[4];
  assign alpha_reg_next_1[6] = alpha_reg_1[5];
  assign alpha_reg_next_1[7] = alpha_reg_1[6];



  assign ctrlOut_hEnd = Delay40_out1_hEnd;

  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        alpha_reg_2[0] <= 1'b0;
        alpha_reg_2[1] <= 1'b0;
        alpha_reg_2[2] <= 1'b0;
        alpha_reg_2[3] <= 1'b0;
        alpha_reg_2[4] <= 1'b0;
        alpha_reg_2[5] <= 1'b0;
        alpha_reg_2[6] <= 1'b0;
        alpha_reg_2[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_2[0] <= alpha_reg_next_2[0];
          alpha_reg_2[1] <= alpha_reg_next_2[1];
          alpha_reg_2[2] <= alpha_reg_next_2[2];
          alpha_reg_2[3] <= alpha_reg_next_2[3];
          alpha_reg_2[4] <= alpha_reg_next_2[4];
          alpha_reg_2[5] <= alpha_reg_next_2[5];
          alpha_reg_2[6] <= alpha_reg_next_2[6];
          alpha_reg_2[7] <= alpha_reg_next_2[7];
        end
      end
    end

  assign Delay40_out1_vStart = alpha_reg_2[7];
  assign alpha_reg_next_2[0] = ctrl_vStart;
  assign alpha_reg_next_2[1] = alpha_reg_2[0];
  assign alpha_reg_next_2[2] = alpha_reg_2[1];
  assign alpha_reg_next_2[3] = alpha_reg_2[2];
  assign alpha_reg_next_2[4] = alpha_reg_2[3];
  assign alpha_reg_next_2[5] = alpha_reg_2[4];
  assign alpha_reg_next_2[6] = alpha_reg_2[5];
  assign alpha_reg_next_2[7] = alpha_reg_2[6];



  assign ctrlOut_vStart = Delay40_out1_vStart;

  always @(posedge clk or posedge reset)
    begin : c_3_process
      if (reset == 1'b1) begin
        alpha_reg_3[0] <= 1'b0;
        alpha_reg_3[1] <= 1'b0;
        alpha_reg_3[2] <= 1'b0;
        alpha_reg_3[3] <= 1'b0;
        alpha_reg_3[4] <= 1'b0;
        alpha_reg_3[5] <= 1'b0;
        alpha_reg_3[6] <= 1'b0;
        alpha_reg_3[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_3[0] <= alpha_reg_next_3[0];
          alpha_reg_3[1] <= alpha_reg_next_3[1];
          alpha_reg_3[2] <= alpha_reg_next_3[2];
          alpha_reg_3[3] <= alpha_reg_next_3[3];
          alpha_reg_3[4] <= alpha_reg_next_3[4];
          alpha_reg_3[5] <= alpha_reg_next_3[5];
          alpha_reg_3[6] <= alpha_reg_next_3[6];
          alpha_reg_3[7] <= alpha_reg_next_3[7];
        end
      end
    end

  assign Delay40_out1_vEnd = alpha_reg_3[7];
  assign alpha_reg_next_3[0] = ctrl_vEnd;
  assign alpha_reg_next_3[1] = alpha_reg_3[0];
  assign alpha_reg_next_3[2] = alpha_reg_3[1];
  assign alpha_reg_next_3[3] = alpha_reg_3[2];
  assign alpha_reg_next_3[4] = alpha_reg_3[3];
  assign alpha_reg_next_3[5] = alpha_reg_3[4];
  assign alpha_reg_next_3[6] = alpha_reg_3[5];
  assign alpha_reg_next_3[7] = alpha_reg_3[6];



  assign ctrlOut_vEnd = Delay40_out1_vEnd;

  always @(posedge clk or posedge reset)
    begin : c_4_process
      if (reset == 1'b1) begin
        alpha_reg_4[0] <= 1'b0;
        alpha_reg_4[1] <= 1'b0;
        alpha_reg_4[2] <= 1'b0;
        alpha_reg_4[3] <= 1'b0;
        alpha_reg_4[4] <= 1'b0;
        alpha_reg_4[5] <= 1'b0;
        alpha_reg_4[6] <= 1'b0;
        alpha_reg_4[7] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_4[0] <= alpha_reg_next_4[0];
          alpha_reg_4[1] <= alpha_reg_next_4[1];
          alpha_reg_4[2] <= alpha_reg_next_4[2];
          alpha_reg_4[3] <= alpha_reg_next_4[3];
          alpha_reg_4[4] <= alpha_reg_next_4[4];
          alpha_reg_4[5] <= alpha_reg_next_4[5];
          alpha_reg_4[6] <= alpha_reg_next_4[6];
          alpha_reg_4[7] <= alpha_reg_next_4[7];
        end
      end
    end

  assign Delay40_out1_valid = alpha_reg_4[7];
  assign alpha_reg_next_4[0] = ctrl_valid;
  assign alpha_reg_next_4[1] = alpha_reg_4[0];
  assign alpha_reg_next_4[2] = alpha_reg_4[1];
  assign alpha_reg_next_4[3] = alpha_reg_4[2];
  assign alpha_reg_next_4[4] = alpha_reg_4[3];
  assign alpha_reg_next_4[5] = alpha_reg_4[4];
  assign alpha_reg_next_4[6] = alpha_reg_4[5];
  assign alpha_reg_next_4[7] = alpha_reg_4[6];



  assign ctrlOut_valid = Delay40_out1_valid;

endmodule  // Harris_HW_ip_src_det_trace

