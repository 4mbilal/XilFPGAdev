// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CornerDetection\Harris_HW_ip_src_Overlay.v
// Created: 2020-01-15 11:28:57
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Harris_HW_ip_src_Overlay
// Source Path: CornerDetection/Harris_HW/HDL Corner Algorithm/Overlay
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Harris_HW_ip_src_Overlay
          (clk,
           reset,
           enb,
           RGBIn_0,
           RGBIn_1,
           RGBIn_2,
           BinaryIn,
           OverlayRGB_0,
           OverlayRGB_1,
           OverlayRGB_2,
           OverlayTransp,
           CtrlIn_hStart,
           CtrlIn_hEnd,
           CtrlIn_vStart,
           CtrlIn_vEnd,
           CtrlIn_valid,
           RGBout_0,
           RGBout_1,
           RGBout_2,
           CtrlOut_hStart,
           CtrlOut_hEnd,
           CtrlOut_vStart,
           CtrlOut_vEnd,
           CtrlOut_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] RGBIn_0;  // uint8
  input   [7:0] RGBIn_1;  // uint8
  input   [7:0] RGBIn_2;  // uint8
  input   [7:0] BinaryIn;  // uint8
  input   [7:0] OverlayRGB_0;  // uint8
  input   [7:0] OverlayRGB_1;  // uint8
  input   [7:0] OverlayRGB_2;  // uint8
  input   [7:0] OverlayTransp;  // uint8
  input   CtrlIn_hStart;
  input   CtrlIn_hEnd;
  input   CtrlIn_vStart;
  input   CtrlIn_vEnd;
  input   CtrlIn_valid;
  output  [7:0] RGBout_0;  // uint8
  output  [7:0] RGBout_1;  // uint8
  output  [7:0] RGBout_2;  // uint8
  output  CtrlOut_hStart;
  output  CtrlOut_hEnd;
  output  CtrlOut_vStart;
  output  CtrlOut_vEnd;
  output  CtrlOut_valid;


  wire [7:0] RGBIn [0:2];  // uint8 [3]
  wire [7:0] Data_Type_Conversion_out1 [0:2];  // ufix8_En8 [3]
  wire [7:0] Data_Type_Conversion_out1_0;  // ufix8_En8
  wire [7:0] Data_Type_Conversion_out1_1;  // ufix8_En8
  wire [7:0] Data_Type_Conversion_out1_2;  // ufix8_En8
  wire [7:0] HwModeRegister_out_1;  // ufix8_En8
  reg [7:0] HwModeRegister_1_reg [0:1];  // ufix8 [2]
  wire [7:0] HwModeRegister_out_2;  // ufix8_En8
  wire [7:0] HwModeRegister_out_3;  // ufix8_En8
  reg [7:0] HwModeRegister_1_reg_1 [0:1];  // ufix8 [2]
  reg [7:0] HwModeRegister_1_reg_2 [0:1];  // ufix8 [2]
  wire [7:0] HwModeRegister_1_reg_next [0:1];  // ufix8_En8 [2]
  wire [7:0] HwModeRegister_1_reg_next_1 [0:1];  // ufix8_En8 [2]
  wire [7:0] HwModeRegister_1_reg_next_2 [0:1];  // ufix8_En8 [2]
  wire [7:0] Delay11_out1 [0:2];  // ufix8_En8 [3]
  wire [7:0] Constant_out1;  // uint8
  wire [7:0] Constant1_out1;  // uint8
  reg [7:0] delayMatch_reg [0:4];  // ufix8 [5]
  wire [7:0] delayMatch_reg_next [0:4];  // ufix8 [5]
  wire [7:0] OverlayTransp_1;  // uint8
  wire [7:0] Switch_out1;  // uint8
  wire [7:0] Add3_out1;  // uint8
  wire [7:0] Data_Type_Conversion1_out1;  // ufix8_En8
  reg [7:0] HwModeRegister1_reg [0:1];  // ufix8 [2]
  wire [7:0] HwModeRegister1_reg_next [0:1];  // ufix8_En8 [2]
  wire [7:0] Delay12_out1;  // ufix8_En8
  wire [15:0] Product_out1 [0:2];  // ufix16_En16 [3]
  wire [7:0] OverlayRGB [0:2];  // uint8 [3]
  wire [7:0] Data_Type_Conversion5_out1 [0:2];  // ufix8_En8 [3]
  wire [7:0] Data_Type_Conversion5_out1_0;  // ufix8_En8
  wire [7:0] Data_Type_Conversion5_out1_1;  // ufix8_En8
  wire [7:0] Data_Type_Conversion5_out1_2;  // ufix8_En8
  wire [7:0] HwModeRegister2_out_1;  // ufix8_En8
  reg [7:0] HwModeRegister2_1_reg [0:6];  // ufix8 [7]
  wire [7:0] HwModeRegister2_out_2;  // ufix8_En8
  wire [7:0] HwModeRegister2_out_3;  // ufix8_En8
  reg [7:0] HwModeRegister2_1_reg_1 [0:6];  // ufix8 [7]
  reg [7:0] HwModeRegister2_1_reg_2 [0:6];  // ufix8 [7]
  wire [7:0] HwModeRegister2_1_reg_next [0:6];  // ufix8_En8 [7]
  wire [7:0] HwModeRegister2_1_reg_next_1 [0:6];  // ufix8_En8 [7]
  wire [7:0] HwModeRegister2_1_reg_next_2 [0:6];  // ufix8_En8 [7]
  wire [7:0] Delay13_out1 [0:2];  // ufix8_En8 [3]
  wire [7:0] Data_Type_Conversion2_out1;  // ufix8_En8
  reg [7:0] HwModeRegister3_reg [0:1];  // ufix8 [2]
  wire [7:0] HwModeRegister3_reg_next [0:1];  // ufix8_En8 [2]
  wire [7:0] Delay14_out1;  // ufix8_En8
  wire [15:0] Product1_out1 [0:2];  // ufix16_En16 [3]
  reg [15:0] Product_out1_1 [0:2];  // ufix16_En16 [3]
  wire [7:0] Product_out1_2 [0:2];  // ufix8_En8 [3]
  reg [15:0] Product1_out1_1 [0:2];  // ufix16_En16 [3]
  wire [7:0] Product1_out1_2 [0:2];  // ufix8_En8 [3]
  wire [7:0] Add_out1 [0:2];  // ufix8_En8 [3]
  reg [7:0] Delay2_out1 [0:2];  // ufix8_En8 [3]
  wire [7:0] Data_Type_Conversion8_out1 [0:2];  // uint8 [3]
  reg  [0:2] alpha_reg;  // ufix1 [3]
  wire [0:2] alpha_reg_next;  // ufix1 [3]
  wire Delay3_out1_hStart;
  reg  [0:2] alpha_reg_1;  // ufix1 [3]
  wire [0:2] alpha_reg_next_1;  // ufix1 [3]
  wire Delay3_out1_hEnd;
  reg  [0:2] alpha_reg_2;  // ufix1 [3]
  wire [0:2] alpha_reg_next_2;  // ufix1 [3]
  wire Delay3_out1_vStart;
  reg  [0:2] alpha_reg_3;  // ufix1 [3]
  wire [0:2] alpha_reg_next_3;  // ufix1 [3]
  wire Delay3_out1_vEnd;
  reg  [0:2] alpha_reg_4;  // ufix1 [3]
  wire [0:2] alpha_reg_next_4;  // ufix1 [3]
  wire Delay3_out1_valid;


  assign RGBIn[0] = RGBIn_0;
  assign RGBIn[1] = RGBIn_1;
  assign RGBIn[2] = RGBIn_2;

  assign Data_Type_Conversion_out1[0] = RGBIn[0];
  assign Data_Type_Conversion_out1[1] = RGBIn[1];
  assign Data_Type_Conversion_out1[2] = RGBIn[2];



  assign Data_Type_Conversion_out1_0 = Data_Type_Conversion_out1[0];

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        HwModeRegister_1_reg[0] <= 8'b00000000;
        HwModeRegister_1_reg[1] <= 8'b00000000;
        HwModeRegister_1_reg_1[0] <= 8'b00000000;
        HwModeRegister_1_reg_1[1] <= 8'b00000000;
        HwModeRegister_1_reg_2[0] <= 8'b00000000;
        HwModeRegister_1_reg_2[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister_1_reg[0] <= HwModeRegister_1_reg_next[0];
          HwModeRegister_1_reg[1] <= HwModeRegister_1_reg_next[1];
          HwModeRegister_1_reg_1[0] <= HwModeRegister_1_reg_next_1[0];
          HwModeRegister_1_reg_1[1] <= HwModeRegister_1_reg_next_1[1];
          HwModeRegister_1_reg_2[0] <= HwModeRegister_1_reg_next_2[0];
          HwModeRegister_1_reg_2[1] <= HwModeRegister_1_reg_next_2[1];
        end
      end
    end

  assign HwModeRegister_1_reg_next[0] = Data_Type_Conversion_out1_0;
  assign HwModeRegister_1_reg_next[1] = HwModeRegister_1_reg[0];
  assign HwModeRegister_out_1 = HwModeRegister_1_reg[1];
  assign HwModeRegister_1_reg_next_1[0] = Data_Type_Conversion_out1_1;
  assign HwModeRegister_1_reg_next_1[1] = HwModeRegister_1_reg_1[0];
  assign HwModeRegister_out_2 = HwModeRegister_1_reg_1[1];
  assign HwModeRegister_1_reg_next_2[0] = Data_Type_Conversion_out1_2;
  assign HwModeRegister_1_reg_next_2[1] = HwModeRegister_1_reg_2[0];
  assign HwModeRegister_out_3 = HwModeRegister_1_reg_2[1];



  assign Data_Type_Conversion_out1_1 = Data_Type_Conversion_out1[1];

  assign Data_Type_Conversion_out1_2 = Data_Type_Conversion_out1[2];

  assign Delay11_out1[0] = HwModeRegister_out_1;
  assign Delay11_out1[1] = HwModeRegister_out_2;
  assign Delay11_out1[2] = HwModeRegister_out_3;

  assign Constant_out1 = 8'b11111111;



  assign Constant1_out1 = 8'b00000000;



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 8'b00000000;
        delayMatch_reg[1] <= 8'b00000000;
        delayMatch_reg[2] <= 8'b00000000;
        delayMatch_reg[3] <= 8'b00000000;
        delayMatch_reg[4] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
        end
      end
    end

  assign OverlayTransp_1 = delayMatch_reg[4];
  assign delayMatch_reg_next[0] = OverlayTransp;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];



  assign Switch_out1 = (BinaryIn == 8'b00000000 ? Constant1_out1 :
              OverlayTransp_1);



  assign Add3_out1 = Constant_out1 - Switch_out1;



  assign Data_Type_Conversion1_out1 = Add3_out1;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        HwModeRegister1_reg[0] <= 8'b00000000;
        HwModeRegister1_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister1_reg[0] <= HwModeRegister1_reg_next[0];
          HwModeRegister1_reg[1] <= HwModeRegister1_reg_next[1];
        end
      end
    end

  assign Delay12_out1 = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[0] = Data_Type_Conversion1_out1;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];



  assign Product_out1[0] = Delay11_out1[0] * Delay12_out1;
  assign Product_out1[1] = Delay11_out1[1] * Delay12_out1;
  assign Product_out1[2] = Delay11_out1[2] * Delay12_out1;



  assign OverlayRGB[0] = OverlayRGB_0;
  assign OverlayRGB[1] = OverlayRGB_1;
  assign OverlayRGB[2] = OverlayRGB_2;

  assign Data_Type_Conversion5_out1[0] = OverlayRGB[0];
  assign Data_Type_Conversion5_out1[1] = OverlayRGB[1];
  assign Data_Type_Conversion5_out1[2] = OverlayRGB[2];



  assign Data_Type_Conversion5_out1_0 = Data_Type_Conversion5_out1[0];

  always @(posedge clk or posedge reset)
    begin : HwModeRegister2_1_process
      if (reset == 1'b1) begin
        HwModeRegister2_1_reg[0] <= 8'b00000000;
        HwModeRegister2_1_reg[1] <= 8'b00000000;
        HwModeRegister2_1_reg[2] <= 8'b00000000;
        HwModeRegister2_1_reg[3] <= 8'b00000000;
        HwModeRegister2_1_reg[4] <= 8'b00000000;
        HwModeRegister2_1_reg[5] <= 8'b00000000;
        HwModeRegister2_1_reg[6] <= 8'b00000000;
        HwModeRegister2_1_reg_1[0] <= 8'b00000000;
        HwModeRegister2_1_reg_1[1] <= 8'b00000000;
        HwModeRegister2_1_reg_1[2] <= 8'b00000000;
        HwModeRegister2_1_reg_1[3] <= 8'b00000000;
        HwModeRegister2_1_reg_1[4] <= 8'b00000000;
        HwModeRegister2_1_reg_1[5] <= 8'b00000000;
        HwModeRegister2_1_reg_1[6] <= 8'b00000000;
        HwModeRegister2_1_reg_2[0] <= 8'b00000000;
        HwModeRegister2_1_reg_2[1] <= 8'b00000000;
        HwModeRegister2_1_reg_2[2] <= 8'b00000000;
        HwModeRegister2_1_reg_2[3] <= 8'b00000000;
        HwModeRegister2_1_reg_2[4] <= 8'b00000000;
        HwModeRegister2_1_reg_2[5] <= 8'b00000000;
        HwModeRegister2_1_reg_2[6] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister2_1_reg[0] <= HwModeRegister2_1_reg_next[0];
          HwModeRegister2_1_reg[1] <= HwModeRegister2_1_reg_next[1];
          HwModeRegister2_1_reg[2] <= HwModeRegister2_1_reg_next[2];
          HwModeRegister2_1_reg[3] <= HwModeRegister2_1_reg_next[3];
          HwModeRegister2_1_reg[4] <= HwModeRegister2_1_reg_next[4];
          HwModeRegister2_1_reg[5] <= HwModeRegister2_1_reg_next[5];
          HwModeRegister2_1_reg[6] <= HwModeRegister2_1_reg_next[6];
          HwModeRegister2_1_reg_1[0] <= HwModeRegister2_1_reg_next_1[0];
          HwModeRegister2_1_reg_1[1] <= HwModeRegister2_1_reg_next_1[1];
          HwModeRegister2_1_reg_1[2] <= HwModeRegister2_1_reg_next_1[2];
          HwModeRegister2_1_reg_1[3] <= HwModeRegister2_1_reg_next_1[3];
          HwModeRegister2_1_reg_1[4] <= HwModeRegister2_1_reg_next_1[4];
          HwModeRegister2_1_reg_1[5] <= HwModeRegister2_1_reg_next_1[5];
          HwModeRegister2_1_reg_1[6] <= HwModeRegister2_1_reg_next_1[6];
          HwModeRegister2_1_reg_2[0] <= HwModeRegister2_1_reg_next_2[0];
          HwModeRegister2_1_reg_2[1] <= HwModeRegister2_1_reg_next_2[1];
          HwModeRegister2_1_reg_2[2] <= HwModeRegister2_1_reg_next_2[2];
          HwModeRegister2_1_reg_2[3] <= HwModeRegister2_1_reg_next_2[3];
          HwModeRegister2_1_reg_2[4] <= HwModeRegister2_1_reg_next_2[4];
          HwModeRegister2_1_reg_2[5] <= HwModeRegister2_1_reg_next_2[5];
          HwModeRegister2_1_reg_2[6] <= HwModeRegister2_1_reg_next_2[6];
        end
      end
    end

  assign HwModeRegister2_1_reg_next[0] = Data_Type_Conversion5_out1_0;
  assign HwModeRegister2_1_reg_next[1] = HwModeRegister2_1_reg[0];
  assign HwModeRegister2_1_reg_next[2] = HwModeRegister2_1_reg[1];
  assign HwModeRegister2_1_reg_next[3] = HwModeRegister2_1_reg[2];
  assign HwModeRegister2_1_reg_next[4] = HwModeRegister2_1_reg[3];
  assign HwModeRegister2_1_reg_next[5] = HwModeRegister2_1_reg[4];
  assign HwModeRegister2_1_reg_next[6] = HwModeRegister2_1_reg[5];
  assign HwModeRegister2_out_1 = HwModeRegister2_1_reg[6];
  assign HwModeRegister2_1_reg_next_1[0] = Data_Type_Conversion5_out1_1;
  assign HwModeRegister2_1_reg_next_1[1] = HwModeRegister2_1_reg_1[0];
  assign HwModeRegister2_1_reg_next_1[2] = HwModeRegister2_1_reg_1[1];
  assign HwModeRegister2_1_reg_next_1[3] = HwModeRegister2_1_reg_1[2];
  assign HwModeRegister2_1_reg_next_1[4] = HwModeRegister2_1_reg_1[3];
  assign HwModeRegister2_1_reg_next_1[5] = HwModeRegister2_1_reg_1[4];
  assign HwModeRegister2_1_reg_next_1[6] = HwModeRegister2_1_reg_1[5];
  assign HwModeRegister2_out_2 = HwModeRegister2_1_reg_1[6];
  assign HwModeRegister2_1_reg_next_2[0] = Data_Type_Conversion5_out1_2;
  assign HwModeRegister2_1_reg_next_2[1] = HwModeRegister2_1_reg_2[0];
  assign HwModeRegister2_1_reg_next_2[2] = HwModeRegister2_1_reg_2[1];
  assign HwModeRegister2_1_reg_next_2[3] = HwModeRegister2_1_reg_2[2];
  assign HwModeRegister2_1_reg_next_2[4] = HwModeRegister2_1_reg_2[3];
  assign HwModeRegister2_1_reg_next_2[5] = HwModeRegister2_1_reg_2[4];
  assign HwModeRegister2_1_reg_next_2[6] = HwModeRegister2_1_reg_2[5];
  assign HwModeRegister2_out_3 = HwModeRegister2_1_reg_2[6];



  assign Data_Type_Conversion5_out1_1 = Data_Type_Conversion5_out1[1];

  assign Data_Type_Conversion5_out1_2 = Data_Type_Conversion5_out1[2];

  assign Delay13_out1[0] = HwModeRegister2_out_1;
  assign Delay13_out1[1] = HwModeRegister2_out_2;
  assign Delay13_out1[2] = HwModeRegister2_out_3;

  assign Data_Type_Conversion2_out1 = Switch_out1;



  always @(posedge clk or posedge reset)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        HwModeRegister3_reg[0] <= 8'b00000000;
        HwModeRegister3_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          HwModeRegister3_reg[0] <= HwModeRegister3_reg_next[0];
          HwModeRegister3_reg[1] <= HwModeRegister3_reg_next[1];
        end
      end
    end

  assign Delay14_out1 = HwModeRegister3_reg[1];
  assign HwModeRegister3_reg_next[0] = Data_Type_Conversion2_out1;
  assign HwModeRegister3_reg_next[1] = HwModeRegister3_reg[0];



  assign Product1_out1[0] = Delay13_out1[0] * Delay14_out1;
  assign Product1_out1[1] = Delay13_out1[1] * Delay14_out1;
  assign Product1_out1[2] = Delay13_out1[2] * Delay14_out1;



  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Product_out1_1[0] <= 16'b0000000000000000;
        Product_out1_1[1] <= 16'b0000000000000000;
        Product_out1_1[2] <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Product_out1_1[0] <= Product_out1[0];
          Product_out1_1[1] <= Product_out1[1];
          Product_out1_1[2] <= Product_out1[2];
        end
      end
    end



  assign Product_out1_2[0] = Product_out1_1[0][15:8];
  assign Product_out1_2[1] = Product_out1_1[1][15:8];
  assign Product_out1_2[2] = Product_out1_1[2][15:8];



  always @(posedge clk or posedge reset)
    begin : PipelineRegister1_process
      if (reset == 1'b1) begin
        Product1_out1_1[0] <= 16'b0000000000000000;
        Product1_out1_1[1] <= 16'b0000000000000000;
        Product1_out1_1[2] <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_out1_1[0] <= Product1_out1[0];
          Product1_out1_1[1] <= Product1_out1[1];
          Product1_out1_1[2] <= Product1_out1[2];
        end
      end
    end



  assign Product1_out1_2[0] = Product1_out1_1[0][15:8];
  assign Product1_out1_2[1] = Product1_out1_1[1][15:8];
  assign Product1_out1_2[2] = Product1_out1_1[2][15:8];



  assign Add_out1[0] = Product_out1_2[0] + Product1_out1_2[0];
  assign Add_out1[1] = Product_out1_2[1] + Product1_out1_2[1];
  assign Add_out1[2] = Product_out1_2[2] + Product1_out1_2[2];



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1[0] <= 8'b00000000;
        Delay2_out1[1] <= 8'b00000000;
        Delay2_out1[2] <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay2_out1[0] <= Add_out1[0];
          Delay2_out1[1] <= Add_out1[1];
          Delay2_out1[2] <= Add_out1[2];
        end
      end
    end



  assign Data_Type_Conversion8_out1[0] = Delay2_out1[0];
  assign Data_Type_Conversion8_out1[1] = Delay2_out1[1];
  assign Data_Type_Conversion8_out1[2] = Delay2_out1[2];



  assign RGBout_0 = Data_Type_Conversion8_out1[0];

  assign RGBout_1 = Data_Type_Conversion8_out1[1];

  assign RGBout_2 = Data_Type_Conversion8_out1[2];

  always @(posedge clk or posedge reset)
    begin : c_process
      if (reset == 1'b1) begin
        alpha_reg[0] <= 1'b0;
        alpha_reg[1] <= 1'b0;
        alpha_reg[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg[0] <= alpha_reg_next[0];
          alpha_reg[1] <= alpha_reg_next[1];
          alpha_reg[2] <= alpha_reg_next[2];
        end
      end
    end

  assign Delay3_out1_hStart = alpha_reg[2];
  assign alpha_reg_next[0] = CtrlIn_hStart;
  assign alpha_reg_next[1] = alpha_reg[0];
  assign alpha_reg_next[2] = alpha_reg[1];



  assign CtrlOut_hStart = Delay3_out1_hStart;

  always @(posedge clk or posedge reset)
    begin : c_1_process
      if (reset == 1'b1) begin
        alpha_reg_1[0] <= 1'b0;
        alpha_reg_1[1] <= 1'b0;
        alpha_reg_1[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_1[0] <= alpha_reg_next_1[0];
          alpha_reg_1[1] <= alpha_reg_next_1[1];
          alpha_reg_1[2] <= alpha_reg_next_1[2];
        end
      end
    end

  assign Delay3_out1_hEnd = alpha_reg_1[2];
  assign alpha_reg_next_1[0] = CtrlIn_hEnd;
  assign alpha_reg_next_1[1] = alpha_reg_1[0];
  assign alpha_reg_next_1[2] = alpha_reg_1[1];



  assign CtrlOut_hEnd = Delay3_out1_hEnd;

  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        alpha_reg_2[0] <= 1'b0;
        alpha_reg_2[1] <= 1'b0;
        alpha_reg_2[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_2[0] <= alpha_reg_next_2[0];
          alpha_reg_2[1] <= alpha_reg_next_2[1];
          alpha_reg_2[2] <= alpha_reg_next_2[2];
        end
      end
    end

  assign Delay3_out1_vStart = alpha_reg_2[2];
  assign alpha_reg_next_2[0] = CtrlIn_vStart;
  assign alpha_reg_next_2[1] = alpha_reg_2[0];
  assign alpha_reg_next_2[2] = alpha_reg_2[1];



  assign CtrlOut_vStart = Delay3_out1_vStart;

  always @(posedge clk or posedge reset)
    begin : c_3_process
      if (reset == 1'b1) begin
        alpha_reg_3[0] <= 1'b0;
        alpha_reg_3[1] <= 1'b0;
        alpha_reg_3[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_3[0] <= alpha_reg_next_3[0];
          alpha_reg_3[1] <= alpha_reg_next_3[1];
          alpha_reg_3[2] <= alpha_reg_next_3[2];
        end
      end
    end

  assign Delay3_out1_vEnd = alpha_reg_3[2];
  assign alpha_reg_next_3[0] = CtrlIn_vEnd;
  assign alpha_reg_next_3[1] = alpha_reg_3[0];
  assign alpha_reg_next_3[2] = alpha_reg_3[1];



  assign CtrlOut_vEnd = Delay3_out1_vEnd;

  always @(posedge clk or posedge reset)
    begin : c_4_process
      if (reset == 1'b1) begin
        alpha_reg_4[0] <= 1'b0;
        alpha_reg_4[1] <= 1'b0;
        alpha_reg_4[2] <= 1'b0;
      end
      else begin
        if (enb) begin
          alpha_reg_4[0] <= alpha_reg_next_4[0];
          alpha_reg_4[1] <= alpha_reg_next_4[1];
          alpha_reg_4[2] <= alpha_reg_next_4[2];
        end
      end
    end

  assign Delay3_out1_valid = alpha_reg_4[2];
  assign alpha_reg_next_4[0] = CtrlIn_valid;
  assign alpha_reg_next_4[1] = alpha_reg_4[0];
  assign alpha_reg_next_4[2] = alpha_reg_4[1];



  assign CtrlOut_valid = Delay3_out1_valid;

endmodule  // Harris_HW_ip_src_Overlay

