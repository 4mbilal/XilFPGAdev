// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\HSG\HSG_IP_src_DataMemory.v
// Created: 2018-10-21 17:42:58
// 
// Generated by MATLAB 9.3 and HDL Coder 3.11
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HSG_IP_src_DataMemory
// Source Path: HSG/HSG/Edge Detector/LineBuffer/DataMemory
// Hierarchy Level: 3
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HSG_IP_src_DataMemory
          (clk,
           reset,
           enb,
           dataIn,
           pushFIFO,
           popFIFO,
           upperPop,
           lineIn,
           lineMask,
           hStartIn,
           load,
           InitializeFlag,
           loadingFlag,
           unloadSEL,
           loadingPaddingRunCount,
           dataOut1,
           dataOut2,
           allLineStart,
           allNextLineStart,
           allFIFOEmpty,
           halfLoaded);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] dataIn;  // uint8
  input   [1:0] pushFIFO;  // ufix2
  input   [1:0] popFIFO;  // ufix2
  input   upperPop;  // ufix1
  input   lineIn;
  input   [1:0] lineMask;  // ufix2
  input   hStartIn;
  input   load;
  input   InitializeFlag;
  input   loadingFlag;
  input   unloadSEL;
  input   [7:0] loadingPaddingRunCount;  // ufix8
  output  [7:0] dataOut1;  // uint8
  output  [7:0] dataOut2;  // uint8
  output  allLineStart;
  output  allNextLineStart;
  output  allFIFOEmpty;
  output  halfLoaded;

  wire pushIn1;
  wire popIn1;
  wire pushIn2;
  wire popIn2;
  wire initValue;
  wire lineFlagIn;
  wire [7:0] LOADCOUNT;  // ufix8
  wire popEnM;
  wire LineIn1;
  wire isLineStart;
  wire [7:0] dataLine1;  // uint8
  wire emptyFlag1;
  wire FIFOEN;
  wire FIFOENB2;
  reg  [0:1] intdelay_reg;  // ufix1 [2]
  wire [0:1] intdelay_reg_next;  // ufix1 [2]
  wire popDelay;
  reg [7:0] intdelay_reg_1 [0:1];  // ufix8 [2]
  wire [7:0] intdelay_reg_next_1 [0:1];  // ufix8 [2]
  wire initValue_1;
  wire lineFlagIn_1;
  wire [7:0] LOADCOUNT_1;  // ufix8
  wire upperPopEn;
  wire dataPop2;
  wire popEnM2;
  wire LineIn2;
  wire isLineStart_1;
  wire [7:0] dataLine2;  // uint8
  wire emptyFlag2;
  wire FIFOEN2;
  wire popEn2;
  reg  [0:1] intdelay_reg_2;  // ufix1 [2]
  wire [0:1] intdelay_reg_next_2;  // ufix1 [2]
  wire popEnM2_1;
  reg [7:0] intdelay_reg_3 [0:1];  // ufix8 [2]
  wire [7:0] intdelay_reg_next_3 [0:1];  // ufix8 [2]


  HSG_IP_src_PushPopSlicer u_SLICER (.pushFIFO(pushFIFO),  // ufix2
                                     .popFIFO(popFIFO),  // ufix2
                                     .pushFIFO1(pushIn1),
                                     .popFIFO1(popIn1),
                                     .pushFIFO2(pushIn2),
                                     .popFIFO2(popIn2)
                                     );

  assign initValue = 1'b0;



  assign lineFlagIn = (InitializeFlag == 1'b0 ? lineIn :
              initValue);



  assign LOADCOUNT = 8'b00000001;



  HSG_IP_src_FIFOLF u_FIFO1LF (.clk(clk),
                               .reset(reset),
                               .enb(enb),
                               .LineIn(lineFlagIn),
                               .Push(pushIn1),
                               .Pop(popEnM),
                               .load(load),
                               .LineOut(LineIn1)
                               );

  HSG_IP_src_FIFOLineStart u_isFIFOLineStart (.clk(clk),
                                              .reset(reset),
                                              .enb(enb),
                                              .lineFlag(LineIn1),
                                              .load(load),
                                              .pop(popEnM),
                                              .isLineStart(isLineStart)
                                              );

  HSG_IP_src_FIFO u_FIFO1 (.clk(clk),
                           .reset(reset),
                           .enb(enb),
                           .dataIn(dataIn),  // uint8
                           .Push(pushIn1),
                           .Pop(popEnM),
                           .load(load),
                           .dataOut(dataLine1),  // uint8
                           .EmptyFlag(emptyFlag1)
                           );

  HSG_IP_src_advanceFIFO u_advanceFIFO (.emptyFlag(emptyFlag1),
                                        .hStart(hStartIn),
                                        .isFIFOLineStart(isLineStart),
                                        .loadingFlag(loadingFlag),
                                        .loadingPaddingRunCount(loadingPaddingRunCount),  // ufix8
                                        .loadValue(LOADCOUNT),  // ufix8
                                        .popEn(FIFOEN)
                                        );

  assign FIFOENB2 = FIFOEN & popIn1;



  assign popEnM = (InitializeFlag == 1'b0 ? FIFOENB2 :
              popIn1);



  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 1'b0;
        intdelay_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
        end
      end
    end

  assign popDelay = intdelay_reg[1];
  assign intdelay_reg_next[0] = popEnM;
  assign intdelay_reg_next[1] = intdelay_reg[0];



  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 8'b00000000;
        intdelay_reg_1[1] <= 8'b00000000;
      end
      else begin
        if (enb && popDelay) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
        end
      end
    end

  assign dataOut1 = intdelay_reg_1[1];
  assign intdelay_reg_next_1[0] = dataLine1;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];



  assign initValue_1 = 1'b0;



  assign lineFlagIn_1 = (InitializeFlag == 1'b0 ? LineIn1 :
              initValue_1);



  assign LOADCOUNT_1 = 8'b00000010;



  assign upperPopEn = upperPop;



  assign dataPop2 = upperPopEn | popIn2;



  HSG_IP_src_FIFOLF_block u_FIFOLF2 (.clk(clk),
                                     .reset(reset),
                                     .enb(enb),
                                     .LineIn(lineFlagIn_1),
                                     .Push(popDelay),
                                     .Pop(popEnM2),
                                     .load(load),
                                     .LineOut(LineIn2)
                                     );

  HSG_IP_src_FIFOLineStart u_isFIFOLineStart_1 (.clk(clk),
                                                .reset(reset),
                                                .enb(enb),
                                                .lineFlag(LineIn2),
                                                .load(load),
                                                .pop(popEnM2),
                                                .isLineStart(isLineStart_1)
                                                );

  HSG_IP_src_FIFO u_FIFO2 (.clk(clk),
                           .reset(reset),
                           .enb(enb),
                           .dataIn(dataLine1),  // uint8
                           .Push(popDelay),
                           .Pop(popEnM2),
                           .load(load),
                           .dataOut(dataLine2),  // uint8
                           .EmptyFlag(emptyFlag2)
                           );

  HSG_IP_src_advanceFIFO u_advanceFIFO_1 (.emptyFlag(emptyFlag2),
                                          .hStart(hStartIn),
                                          .isFIFOLineStart(isLineStart_1),
                                          .loadingFlag(loadingFlag),
                                          .loadingPaddingRunCount(loadingPaddingRunCount),  // ufix8
                                          .loadValue(LOADCOUNT_1),  // ufix8
                                          .popEn(FIFOEN2)
                                          );

  assign popEn2 = popIn2 & FIFOEN2;



  assign popEnM2 = (unloadSEL == 1'b0 ? popEn2 :
              dataPop2);



  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
        end
      end
    end

  assign popEnM2_1 = intdelay_reg_2[1];
  assign intdelay_reg_next_2[0] = popEnM2;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];



  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 8'b00000000;
        intdelay_reg_3[1] <= 8'b00000000;
      end
      else begin
        if (enb && popEnM2_1) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
        end
      end
    end

  assign dataOut2 = intdelay_reg_3[1];
  assign intdelay_reg_next_3[0] = dataLine2;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];



  assign allLineStart = isLineStart;

  HSG_IP_src_unloadLineMask u_unloadLineMask (.islineStart1(isLineStart),
                                              .islineStart2(isLineStart_1),
                                              .lineMask(lineMask),  // ufix2
                                              .allNextLineStart(allNextLineStart)
                                              );

  assign allFIFOEmpty = emptyFlag1 & emptyFlag2;



  assign halfLoaded = isLineStart_1;

endmodule  // HSG_IP_src_DataMemory

