// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\CornerDetection\Harris_HW_ip_src_FIR2DKernel.v
// Created: 2020-01-15 11:28:57
// 
// Generated by MATLAB 9.7 and HDL Coder 3.15
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Harris_HW_ip_src_FIR2DKernel
// Source Path: CornerDetection/Harris_HW/HDL Corner Algorithm/Gradients/Gradx/FIR2DKernel
// Hierarchy Level: 4
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Harris_HW_ip_src_FIR2DKernel
          (clk,
           reset,
           enb,
           dataIn_0,
           dataIn_1,
           dataIn_2,
           vStartIn,
           vEndIn,
           hStartIn,
           hEndIn,
           validIn,
           processData,
           dataOut,
           vStartOut,
           vEndOut,
           hStartOut,
           hEndOut,
           validOut);


  input   clk;
  input   reset;
  input   enb;
  input   [7:0] dataIn_0;  // uint8
  input   [7:0] dataIn_1;  // uint8
  input   [7:0] dataIn_2;  // uint8
  input   vStartIn;
  input   vEndIn;
  input   hStartIn;
  input   hEndIn;
  input   validIn;
  input   processData;
  output  signed [8:0] dataOut;  // sfix9
  output  vStartOut;
  output  vEndOut;
  output  hStartOut;
  output  hEndOut;
  output  validOut;


  reg [7:0] tapDelay_2_reg [0:1];  // ufix8 [2]
  wire [7:0] tapDelay_2_reg_next [0:1];  // ufix8 [2]
  wire [7:0] tapOutData_2 [0:2];  // uint8 [3]
  wire [7:0] tapOutData_2_0;  // uint8
  reg [7:0] preAdd1_stage1_1;  // uint8
  wire [7:0] tapOutData_2_2;  // uint8
  reg [7:0] preAdd1_stage1_2;  // uint8
  wire [8:0] subtractor_sub_temp;  // ufix9
  wire [8:0] subtractor_1;  // ufix9
  wire [8:0] subtractor_2;  // ufix9
  wire signed [8:0] preAdd1_stage1_add_1;  // sfix9
  reg signed [8:0] preAdd1_final_reg;  // sfix9
  reg signed [8:0] multInDelay1_reg [0:1];  // sfix9 [2]
  wire signed [8:0] multInDelay1_reg_next [0:1];  // sfix9 [2]
  wire signed [8:0] multInReg1;  // sfix9
  wire signed [10:0] multOut1;  // sfix11
  reg signed [10:0] multOutDelay1_reg [0:1];  // sfix11 [2]
  wire signed [10:0] multOutDelay1_reg_next [0:1];  // sfix11 [2]
  wire signed [10:0] multOutReg1;  // sfix11
  wire signed [8:0] multOutReg1_conv;  // sfix9
  reg signed [8:0] dataOut_2;  // sfix9
  reg  vStartIn_reg;
  wire vStartIn_reg_vldSig;
  reg  [0:6] vStartOut_fir_latency_reg;  // ufix1 [7]
  wire [0:6] vStartOut_fir_latency_reg_next;  // ufix1 [7]
  reg  vEndIn_reg;
  wire vEndIn_reg_vldSig;
  reg  [0:6] vEndOut_fir_latency_reg;  // ufix1 [7]
  wire [0:6] vEndOut_fir_latency_reg_next;  // ufix1 [7]
  reg  hStartIn_reg;
  wire hStartIn_reg_vldSig;
  reg  [0:6] hStartOut_fir_latency_reg;  // ufix1 [7]
  wire [0:6] hStartOut_fir_latency_reg_next;  // ufix1 [7]
  reg  hEndIn_reg;
  wire hEndIn_reg_vldSig;
  reg  [0:6] hEndOut_fir_latency_reg;  // ufix1 [7]
  wire [0:6] hEndOut_fir_latency_reg_next;  // ufix1 [7]
  reg  validIn_reg;
  wire validIn_reg_vldSig;
  reg  [0:6] validOut_fir_latency_reg;  // ufix1 [7]
  wire [0:6] validOut_fir_latency_reg_next;  // ufix1 [7]


  always @(posedge clk or posedge reset)
    begin : tapDelay_2_process
      if (reset == 1'b1) begin
        tapDelay_2_reg[0] <= 8'b00000000;
        tapDelay_2_reg[1] <= 8'b00000000;
      end
      else begin
        if (enb && processData) begin
          tapDelay_2_reg[0] <= tapDelay_2_reg_next[0];
          tapDelay_2_reg[1] <= tapDelay_2_reg_next[1];
        end
      end
    end

  assign tapOutData_2[0] = tapDelay_2_reg[0];
  assign tapOutData_2[1] = tapDelay_2_reg[1];
  assign tapOutData_2[2] = dataIn_1;
  assign tapDelay_2_reg_next[0] = tapDelay_2_reg[1];
  assign tapDelay_2_reg_next[1] = dataIn_1;



  assign tapOutData_2_0 = tapOutData_2[0];

  always @(posedge clk or posedge reset)
    begin : preAdd1_stage1_1_reg_process
      if (reset == 1'b1) begin
        preAdd1_stage1_1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          preAdd1_stage1_1 <= tapOutData_2_0;
        end
      end
    end



  assign tapOutData_2_2 = tapOutData_2[2];

  always @(posedge clk or posedge reset)
    begin : preAdd1_stage1_2_reg_process
      if (reset == 1'b1) begin
        preAdd1_stage1_2 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          preAdd1_stage1_2 <= tapOutData_2_2;
        end
      end
    end



  assign subtractor_1 = {1'b0, preAdd1_stage1_1};
  assign subtractor_2 = {1'b0, preAdd1_stage1_2};
  assign subtractor_sub_temp = subtractor_1 - subtractor_2;
  assign preAdd1_stage1_add_1 = subtractor_sub_temp;



  always @(posedge clk or posedge reset)
    begin : preAdd1_final_process
      if (reset == 1'b1) begin
        preAdd1_final_reg <= 9'sb000000000;
      end
      else begin
        if (enb) begin
          preAdd1_final_reg <= preAdd1_stage1_add_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : multInDelay1_process
      if (reset == 1'b1) begin
        multInDelay1_reg[0] <= 9'sb000000000;
        multInDelay1_reg[1] <= 9'sb000000000;
      end
      else begin
        if (enb) begin
          multInDelay1_reg[0] <= multInDelay1_reg_next[0];
          multInDelay1_reg[1] <= multInDelay1_reg_next[1];
        end
      end
    end

  assign multInReg1 = multInDelay1_reg[1];
  assign multInDelay1_reg_next[0] = preAdd1_final_reg;
  assign multInDelay1_reg_next[1] = multInDelay1_reg[0];



  assign multOut1 = {{2{multInReg1[8]}}, multInReg1};



  always @(posedge clk or posedge reset)
    begin : multOutDelay1_process
      if (reset == 1'b1) begin
        multOutDelay1_reg[0] <= 11'sb00000000000;
        multOutDelay1_reg[1] <= 11'sb00000000000;
      end
      else begin
        if (enb) begin
          multOutDelay1_reg[0] <= multOutDelay1_reg_next[0];
          multOutDelay1_reg[1] <= multOutDelay1_reg_next[1];
        end
      end
    end

  assign multOutReg1 = multOutDelay1_reg[1];
  assign multOutDelay1_reg_next[0] = multOut1;
  assign multOutDelay1_reg_next[1] = multOutDelay1_reg[0];



  assign multOutReg1_conv = multOutReg1[8:0];



  always @(posedge clk or posedge reset)
    begin : dataOut_1_process
      if (reset == 1'b1) begin
        dataOut_2 <= 9'sb000000000;
      end
      else begin
        if (enb) begin
          dataOut_2 <= multOutReg1_conv;
        end
      end
    end



  // Delay Pixel
  always @(posedge clk or posedge reset)
    begin : vStartOut_tap_latency_process
      if (reset == 1'b1) begin
        vStartIn_reg <= 1'b0;
      end
      else begin
        if (enb && processData) begin
          vStartIn_reg <= vStartIn;
        end
      end
    end



  assign vStartIn_reg_vldSig = vStartIn_reg & processData;



  // Delay Pixel
  always @(posedge clk or posedge reset)
    begin : vStartOut_fir_latency_process
      if (reset == 1'b1) begin
        vStartOut_fir_latency_reg[0] <= 1'b0;
        vStartOut_fir_latency_reg[1] <= 1'b0;
        vStartOut_fir_latency_reg[2] <= 1'b0;
        vStartOut_fir_latency_reg[3] <= 1'b0;
        vStartOut_fir_latency_reg[4] <= 1'b0;
        vStartOut_fir_latency_reg[5] <= 1'b0;
        vStartOut_fir_latency_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          vStartOut_fir_latency_reg[0] <= vStartOut_fir_latency_reg_next[0];
          vStartOut_fir_latency_reg[1] <= vStartOut_fir_latency_reg_next[1];
          vStartOut_fir_latency_reg[2] <= vStartOut_fir_latency_reg_next[2];
          vStartOut_fir_latency_reg[3] <= vStartOut_fir_latency_reg_next[3];
          vStartOut_fir_latency_reg[4] <= vStartOut_fir_latency_reg_next[4];
          vStartOut_fir_latency_reg[5] <= vStartOut_fir_latency_reg_next[5];
          vStartOut_fir_latency_reg[6] <= vStartOut_fir_latency_reg_next[6];
        end
      end
    end

  assign vStartOut = vStartOut_fir_latency_reg[6];
  assign vStartOut_fir_latency_reg_next[0] = vStartIn_reg_vldSig;
  assign vStartOut_fir_latency_reg_next[1] = vStartOut_fir_latency_reg[0];
  assign vStartOut_fir_latency_reg_next[2] = vStartOut_fir_latency_reg[1];
  assign vStartOut_fir_latency_reg_next[3] = vStartOut_fir_latency_reg[2];
  assign vStartOut_fir_latency_reg_next[4] = vStartOut_fir_latency_reg[3];
  assign vStartOut_fir_latency_reg_next[5] = vStartOut_fir_latency_reg[4];
  assign vStartOut_fir_latency_reg_next[6] = vStartOut_fir_latency_reg[5];



  // Delay Horizontal Start
  always @(posedge clk or posedge reset)
    begin : vEndOut_tap_latency_process
      if (reset == 1'b1) begin
        vEndIn_reg <= 1'b0;
      end
      else begin
        if (enb && processData) begin
          vEndIn_reg <= vEndIn;
        end
      end
    end



  assign vEndIn_reg_vldSig = vEndIn_reg & processData;



  // Delay Horizontal Start
  always @(posedge clk or posedge reset)
    begin : vEndOut_fir_latency_process
      if (reset == 1'b1) begin
        vEndOut_fir_latency_reg[0] <= 1'b0;
        vEndOut_fir_latency_reg[1] <= 1'b0;
        vEndOut_fir_latency_reg[2] <= 1'b0;
        vEndOut_fir_latency_reg[3] <= 1'b0;
        vEndOut_fir_latency_reg[4] <= 1'b0;
        vEndOut_fir_latency_reg[5] <= 1'b0;
        vEndOut_fir_latency_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          vEndOut_fir_latency_reg[0] <= vEndOut_fir_latency_reg_next[0];
          vEndOut_fir_latency_reg[1] <= vEndOut_fir_latency_reg_next[1];
          vEndOut_fir_latency_reg[2] <= vEndOut_fir_latency_reg_next[2];
          vEndOut_fir_latency_reg[3] <= vEndOut_fir_latency_reg_next[3];
          vEndOut_fir_latency_reg[4] <= vEndOut_fir_latency_reg_next[4];
          vEndOut_fir_latency_reg[5] <= vEndOut_fir_latency_reg_next[5];
          vEndOut_fir_latency_reg[6] <= vEndOut_fir_latency_reg_next[6];
        end
      end
    end

  assign vEndOut = vEndOut_fir_latency_reg[6];
  assign vEndOut_fir_latency_reg_next[0] = vEndIn_reg_vldSig;
  assign vEndOut_fir_latency_reg_next[1] = vEndOut_fir_latency_reg[0];
  assign vEndOut_fir_latency_reg_next[2] = vEndOut_fir_latency_reg[1];
  assign vEndOut_fir_latency_reg_next[3] = vEndOut_fir_latency_reg[2];
  assign vEndOut_fir_latency_reg_next[4] = vEndOut_fir_latency_reg[3];
  assign vEndOut_fir_latency_reg_next[5] = vEndOut_fir_latency_reg[4];
  assign vEndOut_fir_latency_reg_next[6] = vEndOut_fir_latency_reg[5];



  // Delay Horizontal End
  always @(posedge clk or posedge reset)
    begin : hStartOut_tap_latency_process
      if (reset == 1'b1) begin
        hStartIn_reg <= 1'b0;
      end
      else begin
        if (enb && processData) begin
          hStartIn_reg <= hStartIn;
        end
      end
    end



  assign hStartIn_reg_vldSig = hStartIn_reg & processData;



  // Delay Horizontal End
  always @(posedge clk or posedge reset)
    begin : hStartOut_fir_latency_process
      if (reset == 1'b1) begin
        hStartOut_fir_latency_reg[0] <= 1'b0;
        hStartOut_fir_latency_reg[1] <= 1'b0;
        hStartOut_fir_latency_reg[2] <= 1'b0;
        hStartOut_fir_latency_reg[3] <= 1'b0;
        hStartOut_fir_latency_reg[4] <= 1'b0;
        hStartOut_fir_latency_reg[5] <= 1'b0;
        hStartOut_fir_latency_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartOut_fir_latency_reg[0] <= hStartOut_fir_latency_reg_next[0];
          hStartOut_fir_latency_reg[1] <= hStartOut_fir_latency_reg_next[1];
          hStartOut_fir_latency_reg[2] <= hStartOut_fir_latency_reg_next[2];
          hStartOut_fir_latency_reg[3] <= hStartOut_fir_latency_reg_next[3];
          hStartOut_fir_latency_reg[4] <= hStartOut_fir_latency_reg_next[4];
          hStartOut_fir_latency_reg[5] <= hStartOut_fir_latency_reg_next[5];
          hStartOut_fir_latency_reg[6] <= hStartOut_fir_latency_reg_next[6];
        end
      end
    end

  assign hStartOut = hStartOut_fir_latency_reg[6];
  assign hStartOut_fir_latency_reg_next[0] = hStartIn_reg_vldSig;
  assign hStartOut_fir_latency_reg_next[1] = hStartOut_fir_latency_reg[0];
  assign hStartOut_fir_latency_reg_next[2] = hStartOut_fir_latency_reg[1];
  assign hStartOut_fir_latency_reg_next[3] = hStartOut_fir_latency_reg[2];
  assign hStartOut_fir_latency_reg_next[4] = hStartOut_fir_latency_reg[3];
  assign hStartOut_fir_latency_reg_next[5] = hStartOut_fir_latency_reg[4];
  assign hStartOut_fir_latency_reg_next[6] = hStartOut_fir_latency_reg[5];



  // Delay Vertical Start
  always @(posedge clk or posedge reset)
    begin : hEndOut_tap_latency_process
      if (reset == 1'b1) begin
        hEndIn_reg <= 1'b0;
      end
      else begin
        if (enb && processData) begin
          hEndIn_reg <= hEndIn;
        end
      end
    end



  assign hEndIn_reg_vldSig = hEndIn_reg & processData;



  // Delay Vertical Start
  always @(posedge clk or posedge reset)
    begin : hEndOut_fir_latency_process
      if (reset == 1'b1) begin
        hEndOut_fir_latency_reg[0] <= 1'b0;
        hEndOut_fir_latency_reg[1] <= 1'b0;
        hEndOut_fir_latency_reg[2] <= 1'b0;
        hEndOut_fir_latency_reg[3] <= 1'b0;
        hEndOut_fir_latency_reg[4] <= 1'b0;
        hEndOut_fir_latency_reg[5] <= 1'b0;
        hEndOut_fir_latency_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          hEndOut_fir_latency_reg[0] <= hEndOut_fir_latency_reg_next[0];
          hEndOut_fir_latency_reg[1] <= hEndOut_fir_latency_reg_next[1];
          hEndOut_fir_latency_reg[2] <= hEndOut_fir_latency_reg_next[2];
          hEndOut_fir_latency_reg[3] <= hEndOut_fir_latency_reg_next[3];
          hEndOut_fir_latency_reg[4] <= hEndOut_fir_latency_reg_next[4];
          hEndOut_fir_latency_reg[5] <= hEndOut_fir_latency_reg_next[5];
          hEndOut_fir_latency_reg[6] <= hEndOut_fir_latency_reg_next[6];
        end
      end
    end

  assign hEndOut = hEndOut_fir_latency_reg[6];
  assign hEndOut_fir_latency_reg_next[0] = hEndIn_reg_vldSig;
  assign hEndOut_fir_latency_reg_next[1] = hEndOut_fir_latency_reg[0];
  assign hEndOut_fir_latency_reg_next[2] = hEndOut_fir_latency_reg[1];
  assign hEndOut_fir_latency_reg_next[3] = hEndOut_fir_latency_reg[2];
  assign hEndOut_fir_latency_reg_next[4] = hEndOut_fir_latency_reg[3];
  assign hEndOut_fir_latency_reg_next[5] = hEndOut_fir_latency_reg[4];
  assign hEndOut_fir_latency_reg_next[6] = hEndOut_fir_latency_reg[5];



  // Delay Vertical End
  always @(posedge clk or posedge reset)
    begin : validOut_tap_latency_process
      if (reset == 1'b1) begin
        validIn_reg <= 1'b0;
      end
      else begin
        if (enb && processData) begin
          validIn_reg <= validIn;
        end
      end
    end



  assign validIn_reg_vldSig = validIn_reg & processData;



  // Delay Vertical End
  always @(posedge clk or posedge reset)
    begin : validOut_fir_latency_process
      if (reset == 1'b1) begin
        validOut_fir_latency_reg[0] <= 1'b0;
        validOut_fir_latency_reg[1] <= 1'b0;
        validOut_fir_latency_reg[2] <= 1'b0;
        validOut_fir_latency_reg[3] <= 1'b0;
        validOut_fir_latency_reg[4] <= 1'b0;
        validOut_fir_latency_reg[5] <= 1'b0;
        validOut_fir_latency_reg[6] <= 1'b0;
      end
      else begin
        if (enb) begin
          validOut_fir_latency_reg[0] <= validOut_fir_latency_reg_next[0];
          validOut_fir_latency_reg[1] <= validOut_fir_latency_reg_next[1];
          validOut_fir_latency_reg[2] <= validOut_fir_latency_reg_next[2];
          validOut_fir_latency_reg[3] <= validOut_fir_latency_reg_next[3];
          validOut_fir_latency_reg[4] <= validOut_fir_latency_reg_next[4];
          validOut_fir_latency_reg[5] <= validOut_fir_latency_reg_next[5];
          validOut_fir_latency_reg[6] <= validOut_fir_latency_reg_next[6];
        end
      end
    end

  assign validOut = validOut_fir_latency_reg[6];
  assign validOut_fir_latency_reg_next[0] = validIn_reg_vldSig;
  assign validOut_fir_latency_reg_next[1] = validOut_fir_latency_reg[0];
  assign validOut_fir_latency_reg_next[2] = validOut_fir_latency_reg[1];
  assign validOut_fir_latency_reg_next[3] = validOut_fir_latency_reg[2];
  assign validOut_fir_latency_reg_next[4] = validOut_fir_latency_reg[3];
  assign validOut_fir_latency_reg_next[5] = validOut_fir_latency_reg[4];
  assign validOut_fir_latency_reg_next[6] = validOut_fir_latency_reg[5];



  assign dataOut = dataOut_2;

endmodule  // Harris_HW_ip_src_FIR2DKernel

